<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>helpers.spectral_helper &#8212; pySDC 5.6 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/classic.css?v=2bf1fcf8" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=c40552b6" />
    
    <script src="../../_static/documentation_options.js?v=81710850"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">pySDC 5.6 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">helpers.spectral_helper</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for helpers.spectral_helper</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pySDC.implementations.datatype_classes.mesh</span><span class="w"> </span><span class="kn">import</span> <span class="n">mesh</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.special</span><span class="w"> </span><span class="kn">import</span> <span class="n">factorial</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">partial</span><span class="p">,</span> <span class="n">wraps</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>


<div class="viewcode-block" id="cache">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.cache">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cache</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decorator for caching return values of functions.</span>
<span class="sd">    This is very similar to `functools.cache`, but without the memory leaks (see</span>
<span class="sd">    https://docs.astral.sh/ruff/rules/cached-instance-method/).</span>

<span class="sd">    Example:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        num_calls = 0</span>

<span class="sd">        @cache</span>
<span class="sd">        def increment(x):</span>
<span class="sd">            num_calls += 1</span>
<span class="sd">            return x + 1</span>

<span class="sd">        increment(0)  # returns 1, num_calls = 1</span>
<span class="sd">        increment(1)  # returns 2, num_calls = 2</span>
<span class="sd">        increment(0)  # returns 1, num_calls = 2</span>


<span class="sd">    Args:</span>
<span class="sd">        func (function): The function you want to cache the return value of</span>

<span class="sd">    Returns:</span>
<span class="sd">        return value of func</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attr_cache</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">_cache&quot;</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr_cache</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr_cache</span><span class="p">,</span> <span class="p">{})</span>

        <span class="n">cache</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr_cache</span><span class="p">)</span>

        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">return</span> <span class="n">wrapper</span></div>



<div class="viewcode-block" id="SpectralHelper1D">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper1D">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SpectralHelper1D</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract base class for 1D spectral discretizations. Defines a common interface with parameters and functions that</span>
<span class="sd">    all bases need to have.</span>

<span class="sd">    When implementing new bases, please take care to use the modules that are supplied as class attributes to enable</span>
<span class="sd">    the code for GPUs.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        N (int): Resolution</span>
<span class="sd">        x0 (float): Coordinate of left boundary</span>
<span class="sd">        x1 (float): Coordinate of right boundary</span>
<span class="sd">        L (float): Length of the domain</span>
<span class="sd">        useGPU (bool): Whether to use GPUs</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">fft_lib</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">fft</span>
    <span class="n">sparse_lib</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span>
    <span class="n">linalg</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span>
    <span class="n">xp</span> <span class="o">=</span> <span class="n">np</span>
    <span class="n">distributable</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">useGPU</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">useFFTW</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor</span>

<span class="sd">        Args:</span>
<span class="sd">            N (int): Resolution</span>
<span class="sd">            x0 (float): Coordinate of left boundary</span>
<span class="sd">            x1 (float): Coordinate of right boundary</span>
<span class="sd">            useGPU (bool): Whether to use GPUs</span>
<span class="sd">            useFFTW (bool): Whether to use FFTW for the transforms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="n">N</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x0</span> <span class="o">=</span> <span class="n">x0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x1</span> <span class="o">=</span> <span class="n">x1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">-</span> <span class="n">x0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">useGPU</span> <span class="o">=</span> <span class="n">useGPU</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plans</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">useGPU</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setup_GPU</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setup_CPU</span><span class="p">(</span><span class="n">useFFTW</span><span class="o">=</span><span class="n">useFFTW</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">useGPU</span> <span class="ow">and</span> <span class="n">useFFTW</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Please run either on GPUs or with FFTW, not both!&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="SpectralHelper1D.setup_GPU">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper1D.setup_GPU">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_GPU</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;switch to GPU modules&quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">cupyx.scipy.sparse</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sparse_lib</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">cupyx.scipy.sparse.linalg</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">linalg</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">cupyx.scipy.fft</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">fft_lib</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">pySDC.implementations.datatype_classes.cupy_mesh</span><span class="w"> </span><span class="kn">import</span> <span class="n">cupy_mesh</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">xp</span> <span class="o">=</span> <span class="n">cp</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">sparse_lib</span> <span class="o">=</span> <span class="n">sparse_lib</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">linalg</span> <span class="o">=</span> <span class="n">linalg</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">fft_lib</span> <span class="o">=</span> <span class="n">fft_lib</span></div>


<div class="viewcode-block" id="SpectralHelper1D.setup_CPU">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper1D.setup_CPU">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_CPU</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">useFFTW</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;switch to CPU modules&quot;&quot;&quot;</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">xp</span> <span class="o">=</span> <span class="n">np</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">sparse_lib</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">linalg</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span>

        <span class="k">if</span> <span class="n">useFFTW</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">mpi4py_fft</span><span class="w"> </span><span class="kn">import</span> <span class="n">fftw</span>

            <span class="bp">cls</span><span class="o">.</span><span class="n">fft_backend</span> <span class="o">=</span> <span class="s1">&#39;fftw&#39;</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">fft_lib</span> <span class="o">=</span> <span class="n">fftw</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">fft_backend</span> <span class="o">=</span> <span class="s1">&#39;scipy&#39;</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">fft_lib</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">fft</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">fft_comm_backend</span> <span class="o">=</span> <span class="s1">&#39;MPI&#39;</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">mesh</span></div>


<div class="viewcode-block" id="SpectralHelper1D.get_Id">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper1D.get_Id">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_Id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get identity matrix</span>

<span class="sd">        Returns:</span>
<span class="sd">            sparse diagonal identity matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_lib</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpectralHelper1D.get_zero">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper1D.get_zero">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a matrix with all zeros of the correct size.</span>

<span class="sd">        Returns:</span>
<span class="sd">            sparse matrix with zeros everywhere</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_Id</span><span class="p">()</span></div>


<div class="viewcode-block" id="SpectralHelper1D.get_differentiation_matrix">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper1D.get_differentiation_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_differentiation_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>


<div class="viewcode-block" id="SpectralHelper1D.get_integration_matrix">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper1D.get_integration_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_integration_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>


<div class="viewcode-block" id="SpectralHelper1D.get_wavenumbers">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper1D.get_wavenumbers">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_wavenumbers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the grid in spectral space</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<div class="viewcode-block" id="SpectralHelper1D.get_empty_operator_matrix">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper1D.get_empty_operator_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_empty_operator_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">O</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a matrix of operators to be filled with the connections between the solution components.</span>

<span class="sd">        Args:</span>
<span class="sd">            S (int): Number of components in the solution</span>
<span class="sd">            O (sparse matrix): Zero matrix used for initialization</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of lists containing sparse zeros</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[[</span><span class="n">O</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">S</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">S</span><span class="p">)]</span></div>


<div class="viewcode-block" id="SpectralHelper1D.get_basis_change_matrix">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper1D.get_basis_change_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_basis_change_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Some spectral discretization change the basis during differentiation. This method can be used to transfer</span>
<span class="sd">        between the various bases.</span>

<span class="sd">        This method accepts arbitrary arguments that may not be used in order to provide an easy interface for multi-</span>
<span class="sd">        dimensional bases. For instance, you may combine an FFT discretization with an ultraspherical discretization.</span>
<span class="sd">        The FFT discretization will always be in the same base, but the ultraspherical discretization uses a different</span>
<span class="sd">        base for every derivative. You can then ask all bases for transfer matrices from one ultraspherical derivative</span>
<span class="sd">        base to the next. The FFT discretization will ignore this and return an identity while the ultraspherical</span>
<span class="sd">        discretization will return the desired matrix. After a Kronecker product, you get the 2D version of the matrix</span>
<span class="sd">        you want. This is what the `SpectralHelper` does when you call the method of the same name on it.</span>

<span class="sd">        Returns:</span>
<span class="sd">            sparse bases change matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_lib</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpectralHelper1D.get_BC">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper1D.get_BC">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_BC</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kind</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        To facilitate boundary conditions (BCs) we use either a basis where all functions satisfy the BCs automatically,</span>
<span class="sd">        as is the case in FFT basis for periodic BCs, or boundary bordering. In boundary bordering, specific lines in</span>
<span class="sd">        the matrix are replaced by the boundary conditions as obtained by this method.</span>

<span class="sd">        Args:</span>
<span class="sd">            kind (str): The type of BC you want to implement please refer to the implementations of this method in the</span>
<span class="sd">            individual 1D bases for what is implemented</span>

<span class="sd">        Returns:</span>
<span class="sd">            self.xp.array: Boundary condition</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;No boundary conditions of </span><span class="si">{</span><span class="n">kind</span><span class="si">=!r}</span><span class="s1"> implemented!&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpectralHelper1D.get_filter_matrix">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper1D.get_filter_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_filter_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">kmax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a bandpass filter.</span>

<span class="sd">        Args:</span>
<span class="sd">            kmin (int): Lower limit of the bandpass filter</span>
<span class="sd">            kmax (int): Upper limit of the bandpass filter</span>

<span class="sd">        Returns:</span>
<span class="sd">            sparse matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">k</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_wavenumbers</span><span class="p">())</span>

        <span class="n">kmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">if</span> <span class="n">kmax</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">kmax</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="n">kmax</span><span class="p">,</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">kmin</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">useGPU</span><span class="p">:</span>
            <span class="n">Id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_Id</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_Id</span><span class="p">()</span>
        <span class="n">F</span> <span class="o">=</span> <span class="n">Id</span><span class="o">.</span><span class="n">tolil</span><span class="p">()</span>
        <span class="n">F</span><span class="p">[:,</span> <span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span></div>


<div class="viewcode-block" id="SpectralHelper1D.get_1dgrid">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper1D.get_1dgrid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_1dgrid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the grid in physical space</span>

<span class="sd">        Returns:</span>
<span class="sd">            self.xp.array: Grid</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>
</div>



<div class="viewcode-block" id="ChebychevHelper">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.ChebychevHelper">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ChebychevHelper</span><span class="p">(</span><span class="n">SpectralHelper1D</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The Chebychev base consists of special kinds of polynomials, with the main advantage that you can easily transform</span>
<span class="sd">    between physical and spectral space by discrete cosine transform.</span>
<span class="sd">    The differentiation in the Chebychev T base is dense, but can be preconditioned to yield a differentiation operator</span>
<span class="sd">    that moves to Chebychev U basis during differentiation, which is sparse. When using this technique, problems need to</span>
<span class="sd">    be formulated in first order formulation.</span>

<span class="sd">    This implementation is largely based on the Dedalus paper (https://doi.org/10.1103/PhysRevResearch.2.023068).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">x0</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">x1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor.</span>
<span class="sd">        Please refer to the parent class for additional arguments. Notably, you have to supply a resolution `N` and you</span>
<span class="sd">        may choose to run on GPUs via the `useGPU` argument.</span>

<span class="sd">        Args:</span>
<span class="sd">            x0 (float): Coordinate of left boundary. Note that only -1 is currently implented</span>
<span class="sd">            x1 (float): Coordinate of right boundary. Note that only +1 is currently implented</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># need linear transformation y = ax + b with a = (x1-x0)/2 and b = (x1+x0)/2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lin_trf_fac</span> <span class="o">=</span> <span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lin_trf_off</span> <span class="o">=</span> <span class="p">(</span><span class="n">x1</span> <span class="o">+</span> <span class="n">x0</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_norm</span><span class="p">()</span>

<div class="viewcode-block" id="ChebychevHelper.get_1dgrid">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.ChebychevHelper.get_1dgrid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_1dgrid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Generates a 1D grid with Chebychev points. These are clustered at the boundary. You need this kind of grid to</span>
<span class="sd">        use discrete cosine transformation (DCT) to get the Chebychev representation. If you want a different grid, you</span>
<span class="sd">        need to do an affine transformation before any Chebychev business.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: 1D grid</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lin_trf_fac</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">))</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lin_trf_off</span></div>


<div class="viewcode-block" id="ChebychevHelper.get_wavenumbers">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.ChebychevHelper.get_wavenumbers">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_wavenumbers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the domain in spectral space&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span></div>


<div class="viewcode-block" id="ChebychevHelper.get_conv">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.ChebychevHelper.get_conv">[docs]</a>
    <span class="nd">@cache</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_conv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Get conversion matrix between different kinds of polynomials. The supported kinds are</span>
<span class="sd">         - T: Chebychev polynomials of first kind</span>
<span class="sd">         - U: Chebychev polynomials of second kind</span>
<span class="sd">         - D: Dirichlet recombination.</span>

<span class="sd">        You get the desired matrix by choosing a name as ``A2B``. I.e. ``T2U`` for the conversion matrix from T to U.</span>
<span class="sd">        Once generates matrices are cached. So feel free to call the method as often as you like.</span>

<span class="sd">        Args:</span>
<span class="sd">         name (str): Conversion code, e.g. &#39;T2U&#39;</span>
<span class="sd">         N (int): Size of the matrix (optional)</span>

<span class="sd">        Returns:</span>
<span class="sd">            scipy.sparse: Sparse conversion matrix</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">N</span> <span class="k">if</span> <span class="n">N</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
        <span class="n">sp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_lib</span>
        <span class="n">xp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_forward_conv</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;T2U&#39;</span><span class="p">:</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">xp</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">2</span><span class="p">),</span> <span class="n">offsets</span><span class="o">=+</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="n">mat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;D2T&#39;</span><span class="p">:</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">xp</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">2</span><span class="p">),</span> <span class="n">offsets</span><span class="o">=+</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">name</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_lib</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Don</span><span class="se">\&#39;</span><span class="s1">t have conversion matrix </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">mat</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">get_forward_conv</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span> <span class="k">as</span> <span class="n">E</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">fwd</span> <span class="o">=</span> <span class="n">get_forward_conv</span><span class="p">(</span><span class="n">name</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="kn">import</span><span class="w"> </span><span class="nn">scipy.sparse</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_lib</span> <span class="o">==</span> <span class="n">sp</span><span class="p">:</span>
                    <span class="n">mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_lib</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">fwd</span><span class="o">.</span><span class="n">tocsc</span><span class="p">())</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_lib</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">fwd</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">()))</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span> <span class="kn">from</span><span class="w"> </span><span class="nn">E</span>

        <span class="k">return</span> <span class="n">mat</span></div>


<div class="viewcode-block" id="ChebychevHelper.get_basis_change_matrix">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.ChebychevHelper.get_basis_change_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_basis_change_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conv</span><span class="o">=</span><span class="s1">&#39;T2T&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        As the differentiation matrix in Chebychev-T base is dense but is sparse when simultaneously changing base to</span>
<span class="sd">        Chebychev-U, you may need a basis change matrix to transfer the other matrices as well. This function returns a</span>
<span class="sd">        conversion matrix from `ChebychevHelper.get_conv`. Not that `**kwargs` are used to absorb arguments for other</span>
<span class="sd">        bases, see documentation of `SpectralHelper1D.get_basis_change_matrix`.</span>

<span class="sd">        Args:</span>
<span class="sd">            conv (str): Conversion code, i.e. T2U</span>

<span class="sd">        Returns:</span>
<span class="sd">            Sparse conversion matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_conv</span><span class="p">(</span><span class="n">conv</span><span class="p">)</span></div>


<div class="viewcode-block" id="ChebychevHelper.get_integration_matrix">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.ChebychevHelper.get_integration_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_integration_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lbnd</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get matrix for integration</span>

<span class="sd">        Args:</span>
<span class="sd">            lbnd (float): Lower bound for integration, only 0 is currently implemented</span>

<span class="sd">        Returns:</span>
<span class="sd">           Sparse integration matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_lib</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">offsets</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_conv</span><span class="p">(</span><span class="s1">&#39;T2U&#39;</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lbnd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">S</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span>
            <span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
                <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">))</span>
                <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lin_trf_fac</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;This function allows to integrate only from x=0, you attempted from x=</span><span class="si">{</span><span class="n">lbnd</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">S</span></div>


<div class="viewcode-block" id="ChebychevHelper.get_differentiation_matrix">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.ChebychevHelper.get_differentiation_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_differentiation_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Keep in mind that the T2T differentiation matrix is dense.</span>

<span class="sd">        Args:</span>
<span class="sd">            p (int): Derivative you want to compute</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Differentiation matrix</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
                <span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">j</span> <span class="o">*</span> <span class="p">((</span><span class="n">j</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">D</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/=</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_lib</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_power</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">lin_trf_fac</span><span class="o">**</span><span class="n">p</span></div>


<div class="viewcode-block" id="ChebychevHelper.get_norm">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.ChebychevHelper.get_norm">[docs]</a>
    <span class="nd">@cache</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Get normalization for converting Chebychev coefficients and DCT</span>

<span class="sd">        Args:</span>
<span class="sd">            N (int, optional): Resolution</span>

<span class="sd">        Returns:</span>
<span class="sd">            self.xp.array: Normalization</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="k">if</span> <span class="n">N</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">N</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span>
        <span class="n">norm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">norm</span></div>


<div class="viewcode-block" id="ChebychevHelper.transform">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.ChebychevHelper.transform">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        DCT along axes. `kwargs` will be passed on to the FFT library.</span>

<span class="sd">        Args:</span>
<span class="sd">            u: Data you want to transform</span>
<span class="sd">            axes (tuple): Axes you want to transform along</span>

<span class="sd">        Returns:</span>
<span class="sd">            Data in spectral space</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="n">axes</span> <span class="k">if</span> <span class="n">axes</span> <span class="k">else</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">shape</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;norm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;norm&#39;</span><span class="p">,</span> <span class="s1">&#39;backward&#39;</span><span class="p">)</span>

        <span class="n">trf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fft_lib</span><span class="o">.</span><span class="n">dctn</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">&lt;</span> <span class="n">trf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]:</span>
                <span class="c1"># mpi4py-fft implements padding only for FFT, where the frequencies are sorted such that the zeros are</span>
                <span class="c1"># removed in the middle rather than the end. We need to resort this here and put the highest frequencies</span>
                <span class="c1"># in the middle.</span>
                <span class="n">_trf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">trf</span><span class="p">)</span>
                <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
                <span class="n">N_pad</span> <span class="o">=</span> <span class="n">_trf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="n">N</span>
                <span class="n">end_first_half</span> <span class="o">=</span> <span class="n">N</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="c1"># copy first &quot;half&quot;</span>
                <span class="n">su</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">trf</span><span class="o">.</span><span class="n">ndim</span>
                <span class="n">su</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">end_first_half</span><span class="p">)</span>
                <span class="n">_trf</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">su</span><span class="p">)]</span> <span class="o">=</span> <span class="n">trf</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">su</span><span class="p">)]</span>

                <span class="c1"># copy second &quot;half&quot;</span>
                <span class="n">su</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">ndim</span>
                <span class="n">su</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">end_first_half</span> <span class="o">+</span> <span class="n">N_pad</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">s_u</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">ndim</span>
                <span class="n">s_u</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">end_first_half</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
                <span class="n">_trf</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">su</span><span class="p">)]</span> <span class="o">=</span> <span class="n">trf</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">s_u</span><span class="p">)]</span>

                <span class="c1"># # copy values to be cut</span>
                <span class="c1"># su = [slice(None)] * u.ndim</span>
                <span class="c1"># su[axis] = slice(end_first_half, end_first_half + N_pad)</span>
                <span class="c1"># s_u = [slice(None)] * u.ndim</span>
                <span class="c1"># s_u[axis] = slice(-N_pad, None)</span>
                <span class="c1"># _trf[tuple(su)] = trf[tuple(s_u)]</span>

                <span class="n">trf</span> <span class="o">=</span> <span class="n">_trf</span>

            <span class="n">expansion</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
            <span class="n">expansion</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">trf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">norm</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span>
            <span class="n">trf</span> <span class="o">*=</span> <span class="n">norm</span><span class="p">[(</span><span class="o">*</span><span class="n">expansion</span><span class="p">,)]</span>
        <span class="k">return</span> <span class="n">trf</span></div>


<div class="viewcode-block" id="ChebychevHelper.itransform">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.ChebychevHelper.itransform">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">itransform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inverse DCT along axis.</span>

<span class="sd">        Args:</span>
<span class="sd">            u: Data you want to transform</span>
<span class="sd">            axes (tuple): Axes you want to transform along</span>

<span class="sd">        Returns:</span>
<span class="sd">            Data in physical space</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="n">axes</span> <span class="k">if</span> <span class="n">axes</span> <span class="k">else</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">shape</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;norm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;norm&#39;</span><span class="p">,</span> <span class="s1">&#39;backward&#39;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;overwrite_x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;overwrite_x&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">==</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]:</span>
                <span class="n">_u</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># mpi4py-fft implements padding only for FFT, where the frequencies are sorted such that the zeros are</span>
                <span class="c1"># added in the middle rather than the end. We need to resort this here and put the padding in the end.</span>
                <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
                <span class="n">_u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

                <span class="c1"># copy first half</span>
                <span class="n">su</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">ndim</span>
                <span class="n">su</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">_u</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">su</span><span class="p">)]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">su</span><span class="p">)]</span>

                <span class="c1"># copy second half</span>
                <span class="n">su</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">ndim</span>
                <span class="n">su</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">s_u</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">ndim</span>
                <span class="n">s_u</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">N</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">))</span>
                <span class="n">_u</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">s_u</span><span class="p">)]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">su</span><span class="p">)]</span>

                <span class="k">if</span> <span class="n">N</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">su</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">ndim</span>
                    <span class="n">su</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">N</span> <span class="o">//</span> <span class="mi">2</span>
                    <span class="n">_u</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">su</span><span class="p">)]</span> <span class="o">*=</span> <span class="mi">2</span>

            <span class="c1"># generate norm</span>
            <span class="n">expansion</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
            <span class="n">expansion</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">_u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>
            <span class="n">norm</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_norm</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span> <span class="o">*</span> <span class="n">_u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>

            <span class="n">_u</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">[(</span><span class="o">*</span><span class="n">expansion</span><span class="p">,)]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fft_lib</span><span class="o">.</span><span class="n">idctn</span><span class="p">(</span><span class="n">_u</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="ChebychevHelper.get_BC">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.ChebychevHelper.get_BC">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_BC</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get boundary condition row for boundary bordering. `kwargs` will be passed on to implementations of the BC of</span>
<span class="sd">        the kind you choose. Specifically, `x` for `&#39;dirichlet&#39;` boundary condition, which is the coordinate at which to</span>
<span class="sd">        set the BC.</span>

<span class="sd">        Args:</span>
<span class="sd">            kind (&#39;integral&#39; or &#39;dirichlet&#39;): Kind of boundary condition you want</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">kind</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;integral&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_integ_BC_row</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">kind</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;dirichlet&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_Dirichlet_BC_row</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_BC</span><span class="p">(</span><span class="n">kind</span><span class="p">)</span></div>


<div class="viewcode-block" id="ChebychevHelper.get_integ_BC_row">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.ChebychevHelper.get_integ_BC_row">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_integ_BC_row</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a row for generating integral BCs with T polynomials.</span>
<span class="sd">        It returns the values of the integrals of T polynomials over the entire interval.</span>

<span class="sd">        Returns:</span>
<span class="sd">            self.xp.ndarray: Row to put into a matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">me</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">me</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">=</span> <span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">me</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span>
        <span class="k">return</span> <span class="n">me</span></div>


<div class="viewcode-block" id="ChebychevHelper.get_Dirichlet_BC_row">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.ChebychevHelper.get_Dirichlet_BC_row">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_Dirichlet_BC_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a row for generating Dirichlet BCs at x with T polynomials.</span>
<span class="sd">        It returns the values of the T polynomials at x.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (float): Position of the boundary condition</span>

<span class="sd">        Returns:</span>
<span class="sd">            self.xp.ndarray: Row to put into a matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="mi">4</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">return</span> <span class="n">n</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Don</span><span class="se">\&#39;</span><span class="s1">t know how to generate Dirichlet BC</span><span class="se">\&#39;</span><span class="s1">s at </span><span class="si">{</span><span class="n">x</span><span class="si">=}</span><span class="s1">!&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="ChebychevHelper.get_Dirichlet_recombination_matrix">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.ChebychevHelper.get_Dirichlet_recombination_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_Dirichlet_recombination_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Get matrix for Dirichlet recombination, which changes the basis to have sparse boundary conditions.</span>
<span class="sd">        This makes for a good right preconditioner.</span>

<span class="sd">        Returns:</span>
<span class="sd">            scipy.sparse: Sparse conversion matrix</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
        <span class="n">sp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_lib</span>
        <span class="n">xp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span>

        <span class="k">return</span> <span class="n">sp</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">xp</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">2</span><span class="p">),</span> <span class="n">offsets</span><span class="o">=+</span><span class="mi">2</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="UltrasphericalHelper">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.UltrasphericalHelper">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">UltrasphericalHelper</span><span class="p">(</span><span class="n">ChebychevHelper</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This implementation follows https://doi.org/10.1137/120865458.</span>
<span class="sd">    The ultraspherical method works in Chebychev polynomials as well, but also uses various Gegenbauer polynomials.</span>
<span class="sd">    The idea is that for every derivative of Chebychev T polynomials, there is a basis of Gegenbauer polynomials where the differentiation matrix is a single off-diagonal.</span>
<span class="sd">    There are also conversion operators from one derivative basis to the next that are sparse.</span>

<span class="sd">    This basis is used like this: For every equation that you have, look for the highest derivative and bump all matrices to the correct basis. If your highest derivative is 2 and you have an identity, it needs to get bumped from 0 to 1 and from 1 to 2. If you have a first derivative as well, it needs to be bumped from 1 to 2.</span>
<span class="sd">    You don&#39;t need the same resulting basis in all equations. You just need to take care that you translate the right hand side to the correct basis as well.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="UltrasphericalHelper.get_differentiation_matrix">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.UltrasphericalHelper.get_differentiation_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_differentiation_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Notice that while sparse, this matrix is not diagonal, which means the inversion cannot be parallelized easily.</span>

<span class="sd">        Args:</span>
<span class="sd">            p (int): Order of the derivative</span>

<span class="sd">        Returns:</span>
<span class="sd">            sparse differentiation matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_lib</span>
        <span class="n">xp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span>
        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">p</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">xp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">+</span> <span class="n">l</span><span class="p">,</span> <span class="n">offsets</span><span class="o">=</span><span class="n">l</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">lin_trf_fac</span><span class="o">**</span><span class="n">p</span></div>


<div class="viewcode-block" id="UltrasphericalHelper.get_S">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.UltrasphericalHelper.get_S">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_S</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lmbda</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get matrix for bumping the derivative base by one from lmbda to lmbda + 1. This is the same language as in</span>
<span class="sd">        https://doi.org/10.1137/120865458.</span>

<span class="sd">        Args:</span>
<span class="sd">            lmbda (int): Ingoing derivative base</span>

<span class="sd">        Returns:</span>
<span class="sd">            sparse matrix: Conversion from derivative base lmbda to lmbda + 1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>

        <span class="k">if</span> <span class="n">lmbda</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sp</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="p">((</span><span class="n">sp</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">2</span><span class="p">),</span> <span class="n">offsets</span><span class="o">=+</span><span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">tolil</span><span class="p">()</span>
            <span class="n">mat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_lib</span>
            <span class="n">xp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">lmbda</span> <span class="o">/</span> <span class="p">(</span><span class="n">lmbda</span> <span class="o">+</span> <span class="n">xp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)))</span> <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span>
                <span class="n">lmbda</span> <span class="o">/</span> <span class="p">(</span><span class="n">lmbda</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">xp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)),</span> <span class="n">offsets</span><span class="o">=+</span><span class="mi">2</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_lib</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span></div>


<div class="viewcode-block" id="UltrasphericalHelper.get_basis_change_matrix">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.UltrasphericalHelper.get_basis_change_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_basis_change_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p_in</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">p_out</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a conversion matrix from derivative base `p_in` to `p_out`.</span>

<span class="sd">        Args:</span>
<span class="sd">            p_out (int): Resulting derivative base</span>
<span class="sd">            p_in (int): Ingoing derivative base</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mat_fwd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_lib</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">([</span><span class="n">p_in</span><span class="p">,</span> <span class="n">p_out</span><span class="p">]),</span> <span class="nb">max</span><span class="p">([</span><span class="n">p_in</span><span class="p">,</span> <span class="n">p_out</span><span class="p">])):</span>
            <span class="n">mat_fwd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_S</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">@</span> <span class="n">mat_fwd</span>

        <span class="k">if</span> <span class="n">p_out</span> <span class="o">&gt;</span> <span class="n">p_in</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mat_fwd</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># We have to invert the matrix on CPU because the GPU equivalent is not implemented in CuPy at the time of writing.</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">scipy.sparse</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">useGPU</span><span class="p">:</span>
                <span class="n">mat_fwd</span> <span class="o">=</span> <span class="n">mat_fwd</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>

            <span class="n">mat_bck</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">mat_fwd</span><span class="o">.</span><span class="n">tocsc</span><span class="p">())</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_lib</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">(</span><span class="n">mat_bck</span><span class="p">)</span></div>


<div class="viewcode-block" id="UltrasphericalHelper.get_integration_matrix">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.UltrasphericalHelper.get_integration_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_integration_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get an integration matrix. Please use `UltrasphericalHelper.get_integration_constant` afterwards to compute the</span>
<span class="sd">        integration constant such that integration starts from x=-1.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            import numpy as np</span>
<span class="sd">            from pySDC.helpers.spectral_helper import UltrasphericalHelper</span>

<span class="sd">            N = 4</span>
<span class="sd">            helper = UltrasphericalHelper(N)</span>
<span class="sd">            coeffs = np.random.random(N)</span>
<span class="sd">            coeffs[-1] = 0</span>

<span class="sd">            poly = np.polynomial.Chebyshev(coeffs)</span>

<span class="sd">            S = helper.get_integration_matrix()</span>
<span class="sd">            U_hat = S @ coeffs</span>
<span class="sd">            U_hat[0] = helper.get_integration_constant(U_hat, axis=-1)</span>

<span class="sd">            assert np.allclose(poly.integ(lbnd=-1).coef[:-1], U_hat)</span>

<span class="sd">        Returns:</span>
<span class="sd">            sparse integration matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sparse_lib</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">offsets</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<div class="viewcode-block" id="UltrasphericalHelper.get_integration_constant">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.UltrasphericalHelper.get_integration_constant">[docs]</a>
            <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_basis_change_matrix</span><span class="p">(</span><span class="n">p_out</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">p_in</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lin_trf_fac</span>
        <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">get_integration_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u_hat</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get integration constant for lower bound of -1. See documentation of `UltrasphericalHelper.get_integration_matrix` for details.</span>

<span class="sd">        Args:</span>
<span class="sd">            u_hat: Solution in spectral space</span>
<span class="sd">            axis: Axis you want to integrate over</span>

<span class="sd">        Returns:</span>
<span class="sd">            Integration constant, has one less dimension than `u_hat`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span>
            <span class="kc">None</span><span class="p">,</span>
        <span class="p">]</span> <span class="o">*</span> <span class="n">u_hat</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">slices</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">u_hat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">u_hat</span><span class="p">[(</span><span class="o">*</span><span class="n">slices</span><span class="p">,)]</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">u_hat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="FFTHelper">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.FFTHelper">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FFTHelper</span><span class="p">(</span><span class="n">SpectralHelper1D</span><span class="p">):</span>
    <span class="n">distributable</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">x1</span><span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor.</span>
<span class="sd">        Please refer to the parent class for additional arguments. Notably, you have to supply a resolution `N` and you</span>
<span class="sd">        may choose to run on GPUs via the `useGPU` argument.</span>

<span class="sd">        Args:</span>
<span class="sd">            x0 (float, optional): Coordinate of left boundary</span>
<span class="sd">            x1 (float, optional): Coordinate of right boundary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="FFTHelper.get_1dgrid">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.FFTHelper.get_1dgrid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_1dgrid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        We use equally spaced points including the left boundary and not including the right one, which is the left boundary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span></div>


<div class="viewcode-block" id="FFTHelper.get_wavenumbers">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.FFTHelper.get_wavenumbers">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_wavenumbers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Be careful that this ordering is very unintuitive.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span></div>


<div class="viewcode-block" id="FFTHelper.get_differentiation_matrix">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.FFTHelper.get_differentiation_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_differentiation_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This matrix is diagonal, allowing to invert concurrently.</span>

<span class="sd">        Args:</span>
<span class="sd">            p (int): Order of the derivative</span>

<span class="sd">        Returns:</span>
<span class="sd">            sparse differentiation matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_wavenumbers</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">useGPU</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Have to raise the matrix to power p on CPU because the GPU equivalent is not implemented in CuPy at the time of writing.</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.sparse.linalg</span><span class="w"> </span><span class="kn">import</span> <span class="n">matrix_power</span>

                <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_lib</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_lib</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">(</span><span class="n">matrix_power</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_lib</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_power</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sparse_lib</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">k</span><span class="p">),</span> <span class="n">p</span><span class="p">)</span></div>


<div class="viewcode-block" id="FFTHelper.get_integration_matrix">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.FFTHelper.get_integration_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_integration_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get integration matrix to compute `p`-th integral over the entire domain.</span>

<span class="sd">        Args:</span>
<span class="sd">            p (int): Order of integral you want to compute</span>

<span class="sd">        Returns:</span>
<span class="sd">            sparse integration matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_wavenumbers</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;complex128&#39;</span><span class="p">)</span>
        <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_power</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sparse_lib</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">k</span><span class="p">)),</span> <span class="n">p</span><span class="p">)</span></div>


<div class="viewcode-block" id="FFTHelper.get_plan">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.FFTHelper.get_plan">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_plan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">forward</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fft_lib</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;mpi4py_fft.fftw&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;axes&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;axes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;axes&#39;</span><span class="p">])</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">forward</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">me</span> <span class="k">for</span> <span class="n">me</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">plans</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plans</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Generating FFT plan for </span><span class="si">{</span><span class="n">key</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fft_lib</span><span class="o">.</span><span class="n">fftn</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">if</span> <span class="n">forward</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">fft_lib</span><span class="o">.</span><span class="n">ifftn</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plans</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">transform</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plans</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">forward</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fft_lib</span><span class="o">.</span><span class="n">fftn</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;norm&#39;</span><span class="p">,</span> <span class="s1">&#39;backward&#39;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fft_lib</span><span class="o">.</span><span class="n">ifftn</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;norm&#39;</span><span class="p">,</span> <span class="s1">&#39;forward&#39;</span><span class="p">))</span></div>


<div class="viewcode-block" id="FFTHelper.transform">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.FFTHelper.transform">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        FFT along axes. `kwargs` are passed on to the FFT library.</span>

<span class="sd">        Args:</span>
<span class="sd">            u: Data you want to transform</span>
<span class="sd">            axes (tuple): Axes you want to transform over</span>

<span class="sd">        Returns:</span>
<span class="sd">            transformed data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="n">axes</span> <span class="k">if</span> <span class="n">axes</span> <span class="k">else</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">shape</span>
        <span class="n">plan</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_plan</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">forward</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">plan</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="FFTHelper.itransform">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.FFTHelper.itransform">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">itransform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inverse FFT.</span>

<span class="sd">        Args:</span>
<span class="sd">            u: Data you want to transform</span>
<span class="sd">            axes (tuple): Axes over which to transform</span>

<span class="sd">        Returns:</span>
<span class="sd">            transformed data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="n">axes</span> <span class="k">if</span> <span class="n">axes</span> <span class="k">else</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">shape</span>
        <span class="n">plan</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_plan</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">forward</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">plan</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">])</span></div>


<div class="viewcode-block" id="FFTHelper.get_BC">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.FFTHelper.get_BC">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_BC</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kind</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a sort of boundary condition. You can use `kind=integral`, to fix the integral, or you can use `kind=Nyquist`.</span>
<span class="sd">        The latter is not really a boundary condition, but is used to set the Nyquist mode to some value, preferably zero.</span>
<span class="sd">        You should set the Nyquist mode zero when the solution in physical space is real and the resolution is even.</span>

<span class="sd">        Args:</span>
<span class="sd">            kind (&#39;integral&#39; or &#39;nyquist&#39;): Kind of BC</span>

<span class="sd">        Returns:</span>
<span class="sd">            self.xp.ndarray: Boundary condition row</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">kind</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;integral&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_integ_BC_row</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">kind</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;nyquist&#39;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;Do not eliminate the Nyquist mode with odd resolution as it is fully resolved. You chose </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="si">}</span><span class="s1"> in this axis&#39;</span>
            <span class="n">BC</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
            <span class="n">BC</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_Nyquist_mode_index</span><span class="p">()]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">BC</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_BC</span><span class="p">(</span><span class="n">kind</span><span class="p">)</span></div>


<div class="viewcode-block" id="FFTHelper.get_Nyquist_mode_index">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.FFTHelper.get_Nyquist_mode_index">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_Nyquist_mode_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the index of the Nyquist mode, i.e. the mode with the lowest wavenumber, which doesn&#39;t have a positive</span>
<span class="sd">        counterpart for even resolution. This means real waves of this wave number cannot be properly resolved and you</span>
<span class="sd">        are best advised to set this mode zero if representing real functions on even-resolution grids is what you&#39;re</span>
<span class="sd">        after.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: Index of the Nyquist mode</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_wavenumbers</span><span class="p">()</span>
        <span class="n">Nyquist_mode</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="n">Nyquist_mode</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="FFTHelper.get_integ_BC_row">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.FFTHelper.get_integ_BC_row">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_integ_BC_row</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Only the 0-mode has non-zero integral with FFT basis in periodic BCs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">me</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
        <span class="n">me</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
        <span class="k">return</span> <span class="n">me</span></div>
</div>



<div class="viewcode-block" id="SpectralHelper">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SpectralHelper</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class has three functions:</span>
<span class="sd">      - Easily assemble matrices containing multiple equations</span>
<span class="sd">      - Direct product of 1D bases to solve problems in more dimensions</span>
<span class="sd">      - Distribute the FFTs to facilitate concurrency.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        comm (mpi4py.Intracomm): MPI communicator</span>
<span class="sd">        debug (bool): Perform additional checks at extra computational cost</span>
<span class="sd">        useGPU (bool): Whether to use GPUs</span>
<span class="sd">        axes (list): List of 1D bases</span>
<span class="sd">        components (list): List of strings of the names of components in the equations</span>
<span class="sd">        full_BCs (list): List of Dictionaries containing all information about the boundary conditions</span>
<span class="sd">        BC_mat (list): List of lists of sparse matrices to put BCs into and eventually assemble the BC matrix from</span>
<span class="sd">        BCs (sparse matrix): Matrix containing only the BCs</span>
<span class="sd">        fft_cache (dict): Cache FFTs of various shapes here to facilitate padding and so on</span>
<span class="sd">        BC_rhs_mask (self.xp.ndarray): Mask values that contain boundary conditions in the right hand side</span>
<span class="sd">        BC_zero_index (self.xp.ndarray): Indeces of rows in the matrix that are replaced by BCs</span>
<span class="sd">        BC_line_zero_matrix (sparse matrix): Matrix that zeros rows where we can then add the BCs in using `BCs`</span>
<span class="sd">        rhs_BCs_hat (self.xp.ndarray): Boundary conditions in spectral space</span>
<span class="sd">        global_shape (tuple): Global shape of the solution as in `mpi4py-fft`</span>
<span class="sd">        fft_obj: When using distributed FFTs, this will be a parallel transform object from `mpi4py-fft`</span>
<span class="sd">        init (tuple): This is the same `init` that is used throughout the problem classes</span>
<span class="sd">        init_forward (tuple): This is the equivalent of `init` in spectral space</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">xp</span> <span class="o">=</span> <span class="n">np</span>
    <span class="n">fft_lib</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">fft</span>
    <span class="n">sparse_lib</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span>
    <span class="n">linalg</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">mesh</span>
    <span class="n">fft_backend</span> <span class="o">=</span> <span class="s1">&#39;scipy&#39;</span>
    <span class="n">fft_comm_backend</span> <span class="o">=</span> <span class="s1">&#39;MPI&#39;</span>

<div class="viewcode-block" id="SpectralHelper.setup_GPU">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.setup_GPU">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_GPU</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;switch to GPU modules&quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">cupyx.scipy.sparse</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sparse_lib</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">cupyx.scipy.sparse.linalg</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">linalg</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">cupyx.scipy.fft</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">fft_lib</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">pySDC.implementations.datatype_classes.cupy_mesh</span><span class="w"> </span><span class="kn">import</span> <span class="n">cupy_mesh</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">xp</span> <span class="o">=</span> <span class="n">cp</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">sparse_lib</span> <span class="o">=</span> <span class="n">sparse_lib</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">linalg</span> <span class="o">=</span> <span class="n">linalg</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">fft_lib</span> <span class="o">=</span> <span class="n">fft_lib</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">fft_backend</span> <span class="o">=</span> <span class="s1">&#39;cupyx-scipy&#39;</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">fft_comm_backend</span> <span class="o">=</span> <span class="s1">&#39;NCCL&#39;</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">cupy_mesh</span></div>


<div class="viewcode-block" id="SpectralHelper.setup_CPU">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.setup_CPU">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_CPU</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">useFFTW</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;switch to CPU modules&quot;&quot;&quot;</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">xp</span> <span class="o">=</span> <span class="n">np</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">sparse_lib</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">linalg</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span>

        <span class="k">if</span> <span class="n">useFFTW</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">mpi4py_fft</span><span class="w"> </span><span class="kn">import</span> <span class="n">fftw</span>

            <span class="bp">cls</span><span class="o">.</span><span class="n">fft_backend</span> <span class="o">=</span> <span class="s1">&#39;fftw&#39;</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">fft_lib</span> <span class="o">=</span> <span class="n">fftw</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">fft_backend</span> <span class="o">=</span> <span class="s1">&#39;scipy&#39;</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">fft_lib</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">fft</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">fft_comm_backend</span> <span class="o">=</span> <span class="s1">&#39;MPI&#39;</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">mesh</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">useGPU</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor</span>

<span class="sd">        Args:</span>
<span class="sd">            comm (mpi4py.Intracomm): MPI communicator</span>
<span class="sd">            useGPU (bool): Whether to use GPUs</span>
<span class="sd">            debug (bool): Perform additional checks at extra computational cost</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span> <span class="o">=</span> <span class="n">comm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="n">debug</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">useGPU</span> <span class="o">=</span> <span class="n">useGPU</span>

        <span class="k">if</span> <span class="n">useGPU</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setup_GPU</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setup_CPU</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">axes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">components</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">full_BCs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BC_mat</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BCs</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fft_cache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fft_dealias_shape_cache</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Spectral Discretization&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">u_init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get empty data container in physical space</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">init</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">u_init_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get empty data container in spectral space</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">init_forward</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">u_init_physical</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get empty data container in physical space</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">init_physical</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get shape of individual solution component</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">init</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ncomponents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">V</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get domain volume</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="n">me</span><span class="o">.</span><span class="n">L</span> <span class="k">for</span> <span class="n">me</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">])</span>

<div class="viewcode-block" id="SpectralHelper.add_axis">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.add_axis">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an axis to the domain by deciding on suitable 1D base.</span>
<span class="sd">        Arguments to the bases are forwarded using `*args` and `**kwargs`. Please refer to the documentation of the 1D</span>
<span class="sd">        bases for possible arguments.</span>

<span class="sd">        Args:</span>
<span class="sd">            base (str): 1D spectral method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;useGPU&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">useGPU</span>

        <span class="k">if</span> <span class="n">base</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;chebychov&#39;</span><span class="p">,</span> <span class="s1">&#39;chebychev&#39;</span><span class="p">,</span> <span class="s1">&#39;cheby&#39;</span><span class="p">,</span> <span class="s1">&#39;chebychovhelper&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ChebychevHelper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">base</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;fft&#39;</span><span class="p">,</span> <span class="s1">&#39;fourier&#39;</span><span class="p">,</span> <span class="s1">&#39;ffthelper&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">FFTHelper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">base</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ultraspherical&#39;</span><span class="p">,</span> <span class="s1">&#39;gegenbauer&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">UltrasphericalHelper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">base</span><span class="si">=!r}</span><span class="s1"> is not implemented!&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">xp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">sparse_lib</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_lib</span></div>


<div class="viewcode-block" id="SpectralHelper.add_component">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.add_component">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_component</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add solution component(s).</span>

<span class="sd">        Args:</span>
<span class="sd">            name (str or list of strings): Name(s) of component(s)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">me</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_component</span><span class="p">(</span><span class="n">me</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">=!r}</span><span class="s1"> is already added to this problem!&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<div class="viewcode-block" id="SpectralHelper.index">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.index">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the index of component `name`.</span>

<span class="sd">        Args:</span>
<span class="sd">            name (str or list of strings): Name(s) of component(s)</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: Index of the component</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">me</span><span class="p">)</span> <span class="k">for</span> <span class="n">me</span> <span class="ow">in</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Don</span><span class="se">\&#39;</span><span class="s1">t know how to compute index for </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpectralHelper.get_empty_operator_matrix">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.get_empty_operator_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_empty_operator_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">diag</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a matrix of operators to be filled with the connections between the solution components.</span>

<span class="sd">        Args:</span>
<span class="sd">            diag (bool): Whether operator is block-diagonal</span>

<span class="sd">        Returns:</span>
<span class="sd">            list containing sparse zeros</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">S</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">)</span>
        <span class="n">O</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_Id</span><span class="p">()</span> <span class="o">*</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">diag</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">O</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">S</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[[</span><span class="n">O</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">S</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">S</span><span class="p">)]</span></div>


<div class="viewcode-block" id="SpectralHelper.get_BC">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.get_BC">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_BC</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">line</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">scalar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use this method for boundary bordering. It gets the respective matrix row and embeds it into a matrix.</span>
<span class="sd">        Pay attention that if you have multiple BCs in a single equation, you need to put them in different lines.</span>
<span class="sd">        Typically, the last line that does not contain a BC is the best choice.</span>
<span class="sd">        Forward arguments for the boundary conditions using `kwargs`. Refer to documentation of 1D bases for details.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (int): Axis you want to add the BC to</span>
<span class="sd">            kind (str): kind of BC, e.g. Dirichlet</span>
<span class="sd">            line (int): Line you want the BC to go in</span>
<span class="sd">            scalar (bool): Put the BC in all space positions in the other direction</span>

<span class="sd">        Returns:</span>
<span class="sd">            sparse matrix containing the BC</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sp</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span>

        <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>

        <span class="n">BC</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">tolil</span><span class="p">()</span> <span class="o">*</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">useGPU</span><span class="p">:</span>
            <span class="n">BC</span><span class="p">[</span><span class="n">line</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">get_BC</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">BC</span><span class="p">[</span><span class="n">line</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">get_BC</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_lib</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">(</span><span class="n">BC</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">axis2</span> <span class="o">=</span> <span class="p">(</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">ndim</span>

            <span class="k">if</span> <span class="n">scalar</span><span class="p">:</span>
                <span class="n">_Id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_lib</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis2</span><span class="p">]</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_Id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis2</span><span class="p">]</span><span class="o">.</span><span class="n">get_Id</span><span class="p">()</span>

            <span class="n">Id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_local_slice_of_1D_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis2</span><span class="p">]</span><span class="o">.</span><span class="n">get_Id</span><span class="p">()</span> <span class="o">@</span> <span class="n">_Id</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis2</span><span class="p">)</span>

            <span class="n">mats</span> <span class="o">=</span> <span class="p">[</span>
                <span class="kc">None</span><span class="p">,</span>
            <span class="p">]</span> <span class="o">*</span> <span class="n">ndim</span>
            <span class="n">mats</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_local_slice_of_1D_matrix</span><span class="p">(</span><span class="n">BC</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
            <span class="n">mats</span><span class="p">[</span><span class="n">axis2</span><span class="p">]</span> <span class="o">=</span> <span class="n">Id</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_lib</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sparse_lib</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="o">*</span><span class="n">mats</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">mats</span> <span class="o">=</span> <span class="p">[</span>
                <span class="kc">None</span><span class="p">,</span>
            <span class="p">]</span> <span class="o">*</span> <span class="n">ndim</span>

            <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">ax</span> <span class="o">==</span> <span class="n">axis</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">scalar</span><span class="p">:</span>
                    <span class="n">_Id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_lib</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_Id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span><span class="o">.</span><span class="n">get_Id</span><span class="p">()</span>

                <span class="n">mats</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_local_slice_of_1D_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span><span class="o">.</span><span class="n">get_Id</span><span class="p">()</span> <span class="o">@</span> <span class="n">_Id</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

            <span class="n">mats</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_local_slice_of_1D_matrix</span><span class="p">(</span><span class="n">BC</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

            <span class="n">mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_lib</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sparse_lib</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">mats</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_lib</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="o">*</span><span class="n">mats</span><span class="p">[</span><span class="mi">1</span><span class="p">:])))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Matrix expansion for boundary conditions not implemented for </span><span class="si">{</span><span class="n">ndim</span><span class="si">}</span><span class="s1"> dimensions!&#39;</span>
            <span class="p">)</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eliminate_zeros</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mat</span></div>


<div class="viewcode-block" id="SpectralHelper.remove_BC">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.remove_BC">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">remove_BC</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">,</span> <span class="n">equation</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">line</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">scalar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove a BC from the matrix. This is useful e.g. when you add a non-scalar BC and then need to selectively</span>
<span class="sd">        remove single BCs again, as in incompressible Navier-Stokes, for instance.</span>
<span class="sd">        Forwards arguments for the boundary conditions using `kwargs`. Refer to documentation of 1D bases for details.</span>

<span class="sd">        Args:</span>
<span class="sd">            component (str): Name of the component the BC should act on</span>
<span class="sd">            equation (str): Name of the equation for the component you want to put the BC in</span>
<span class="sd">            axis (int): Axis you want to add the BC to</span>
<span class="sd">            kind (str): kind of BC, e.g. Dirichlet</span>
<span class="sd">            v: Value of the BC</span>
<span class="sd">            line (int): Line you want the BC to go in</span>
<span class="sd">            scalar (bool): Put the BC in all space positions in the other direction</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_BC</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_BC</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="n">line</span><span class="p">,</span> <span class="n">scalar</span><span class="o">=</span><span class="n">scalar</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">_BC</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eliminate_zeros</span><span class="p">(</span><span class="n">_BC</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BC_mat</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">equation</span><span class="p">)][</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">component</span><span class="p">)]</span> <span class="o">-=</span> <span class="n">_BC</span>

        <span class="k">if</span> <span class="n">scalar</span><span class="p">:</span>
            <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">equation</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span>
                <span class="mi">0</span><span class="p">,</span>
            <span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span>
            <span class="n">slices</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">line</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slices</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">equation</span><span class="p">)]</span>
                <span class="o">+</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">init</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">axis</span><span class="p">)]</span>
                <span class="o">+</span> <span class="p">[</span><span class="n">line</span><span class="p">]</span>
                <span class="o">+</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">init</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">))]</span>
            <span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">N</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="n">line</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">local_slice</span><span class="p">()[</span><span class="n">axis</span><span class="p">]]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">BC_rhs_mask</span><span class="p">[(</span><span class="o">*</span><span class="n">slices</span><span class="p">,)]</span> <span class="o">=</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="SpectralHelper.add_BC">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.add_BC">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_BC</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">,</span> <span class="n">equation</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">line</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">scalar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a BC to the matrix. Note that you need to convert the list of lists of BCs that this method generates to a</span>
<span class="sd">        single sparse matrix by calling `setup_BCs` after adding/removing all BCs.</span>
<span class="sd">        Forward arguments for the boundary conditions using `kwargs`. Refer to documentation of 1D bases for details.</span>

<span class="sd">        Args:</span>
<span class="sd">            component (str): Name of the component the BC should act on</span>
<span class="sd">            equation (str): Name of the equation for the component you want to put the BC in</span>
<span class="sd">            axis (int): Axis you want to add the BC to</span>
<span class="sd">            kind (str): kind of BC, e.g. Dirichlet</span>
<span class="sd">            v: Value of the BC</span>
<span class="sd">            line (int): Line you want the BC to go in</span>
<span class="sd">            scalar (bool): Put the BC in all space positions in the other direction</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_BC</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_BC</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="n">line</span><span class="p">,</span> <span class="n">scalar</span><span class="o">=</span><span class="n">scalar</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BC_mat</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">equation</span><span class="p">)][</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">component</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">_BC</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">full_BCs</span> <span class="o">+=</span> <span class="p">[</span>
            <span class="p">{</span>
                <span class="s1">&#39;component&#39;</span><span class="p">:</span> <span class="n">component</span><span class="p">,</span>
                <span class="s1">&#39;equation&#39;</span><span class="p">:</span> <span class="n">equation</span><span class="p">,</span>
                <span class="s1">&#39;axis&#39;</span><span class="p">:</span> <span class="n">axis</span><span class="p">,</span>
                <span class="s1">&#39;kind&#39;</span><span class="p">:</span> <span class="n">kind</span><span class="p">,</span>
                <span class="s1">&#39;v&#39;</span><span class="p">:</span> <span class="n">v</span><span class="p">,</span>
                <span class="s1">&#39;line&#39;</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span>
                <span class="s1">&#39;scalar&#39;</span><span class="p">:</span> <span class="n">scalar</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="n">scalar</span><span class="p">:</span>
            <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">equation</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span>
                <span class="mi">0</span><span class="p">,</span>
            <span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span>
            <span class="n">slices</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">line</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">BC_rhs_mask</span><span class="p">[(</span><span class="o">*</span><span class="n">slices</span><span class="p">,)]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">BC_rhs_mask</span><span class="p">[(</span><span class="o">*</span><span class="n">slices</span><span class="p">,)]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">equation</span><span class="p">),</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">global_slice</span><span class="p">(</span><span class="kc">True</span><span class="p">)]</span>
            <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">N</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="n">line</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indices</span><span class="p">(</span><span class="kc">True</span><span class="p">)[</span><span class="n">axis</span><span class="p">]:</span>
                <span class="n">slices</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="n">line</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_slice</span><span class="p">()[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">start</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">BC_rhs_mask</span><span class="p">[(</span><span class="o">*</span><span class="n">slices</span><span class="p">,)]</span> <span class="o">=</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="SpectralHelper.setup_BCs">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.setup_BCs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_BCs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the list of lists of BCs to the boundary condition operator.</span>
<span class="sd">        Also, boundary bordering requires to zero out all other entries in the matrix in rows containing a boundary</span>
<span class="sd">        condition. This method sets up a suitable sparse matrix to do this.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_lib</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BCs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_operator_matrix_to_operator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">BC_mat</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BC_zero_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">init</span><span class="p">[</span><span class="mi">0</span><span class="p">]))[</span><span class="bp">self</span><span class="o">.</span><span class="n">BC_rhs_mask</span><span class="o">.</span><span class="n">flatten</span><span class="p">()]</span>

        <span class="n">diags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">BCs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">diags</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">BC_zero_index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BC_line_zero_matrix</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">diags</span><span class="p">)</span>

        <span class="c1"># prepare BCs in spectral space to easily add to the RHS</span>
        <span class="n">rhs_BCs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">put_BCs_in_rhs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_init</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rhs_BCs_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">rhs_BCs</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpectralHelper.check_BCs">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.check_BCs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">check_BCs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check that the solution satisfies the boundary conditions</span>

<span class="sd">        Args:</span>
<span class="sd">            u: The solution you want to check</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span>
        <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
            <span class="n">BCs</span> <span class="o">=</span> <span class="p">[</span><span class="n">me</span> <span class="k">for</span> <span class="n">me</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_BCs</span> <span class="k">if</span> <span class="n">me</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">axis</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">me</span><span class="p">[</span><span class="s2">&quot;scalar&quot;</span><span class="p">]]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">BCs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">u_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="n">axis</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">,))</span>
                <span class="k">for</span> <span class="n">BC</span> <span class="ow">in</span> <span class="n">BCs</span><span class="p">:</span>
                    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="n">key</span><span class="p">:</span> <span class="n">value</span>
                        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">BC</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;component&#39;</span><span class="p">,</span> <span class="s1">&#39;equation&#39;</span><span class="p">,</span> <span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="s1">&#39;line&#39;</span><span class="p">,</span> <span class="s1">&#39;scalar&#39;</span><span class="p">]</span>
                    <span class="p">}</span>

                    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">get</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">get_BC</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">@</span> <span class="n">u_hat</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">BC</span><span class="p">[</span><span class="s1">&#39;component&#39;</span><span class="p">])]</span>
                    <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">get</span> <span class="o">=</span> <span class="n">u_hat</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">BC</span><span class="p">[</span><span class="s1">&#39;component&#39;</span><span class="p">])]</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">get_BC</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="n">want</span> <span class="o">=</span> <span class="n">BC</span><span class="p">[</span><span class="s1">&#39;v&#39;</span><span class="p">]</span>
                    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span>
                        <span class="n">get</span><span class="p">,</span> <span class="n">want</span>
                    <span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;Unexpected BC in </span><span class="si">{</span><span class="n">BC</span><span class="p">[</span><span class="s2">&quot;component&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1"> in equation </span><span class="si">{</span><span class="n">BC</span><span class="p">[</span><span class="s2">&quot;equation&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">, line </span><span class="si">{</span><span class="n">BC</span><span class="p">[</span><span class="s2">&quot;line&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">! Got </span><span class="si">{</span><span class="n">get</span><span class="si">}</span><span class="s1">, wanted </span><span class="si">{</span><span class="n">want</span><span class="si">}</span><span class="s1">&#39;</span></div>


<div class="viewcode-block" id="SpectralHelper.put_BCs_in_matrix">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.put_BCs_in_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">put_BCs_in_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Put the boundary conditions in a matrix by replacing rows with BCs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">BC_line_zero_matrix</span> <span class="o">@</span> <span class="n">A</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">BCs</span></div>


<div class="viewcode-block" id="SpectralHelper.put_BCs_in_rhs_hat">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.put_BCs_in_rhs_hat">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">put_BCs_in_rhs_hat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs_hat</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Put the BCs in the right hand side in spectral space for solving.</span>
<span class="sd">        This function needs no transforms and caches a mask for faster subsequent use.</span>

<span class="sd">        Args:</span>
<span class="sd">            rhs_hat: Right hand side in spectral space</span>

<span class="sd">        Returns:</span>
<span class="sd">            rhs in spectral space with BCs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_rhs_hat_zero_mask&#39;</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Generate a mask where we need to set values in the rhs in spectral space to zero, such that can replace them</span>
<span class="sd">            by the boundary conditions. The mask is then cached.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rhs_hat_zero_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">newDistArray</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_BCs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="n">bc</span><span class="p">[</span><span class="s1">&#39;axis&#39;</span><span class="p">]:</span>
                        <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">bc</span><span class="p">[</span><span class="s1">&#39;equation&#39;</span><span class="p">]),</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">global_slice</span><span class="p">(</span><span class="kc">True</span><span class="p">)]</span>
                        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">N</span>
                        <span class="n">line</span> <span class="o">=</span> <span class="n">bc</span><span class="p">[</span><span class="s1">&#39;line&#39;</span><span class="p">]</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="n">line</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indices</span><span class="p">(</span><span class="kc">True</span><span class="p">)[</span><span class="n">axis</span><span class="p">]:</span>
                            <span class="n">slices</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="n">line</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_slice</span><span class="p">()[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">start</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_rhs_hat_zero_mask</span><span class="p">[(</span><span class="o">*</span><span class="n">slices</span><span class="p">,)]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">rhs_hat</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_rhs_hat_zero_mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">rhs_hat</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">rhs_BCs_hat</span></div>


<div class="viewcode-block" id="SpectralHelper.put_BCs_in_rhs">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.put_BCs_in_rhs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">put_BCs_in_rhs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Put the BCs in the right hand side for solving.</span>
<span class="sd">        This function will transform along each axis individually and add all BCs in that axis.</span>
<span class="sd">        Consider `put_BCs_in_rhs_hat` to add BCs with no extra transforms needed.</span>

<span class="sd">        Args:</span>
<span class="sd">            rhs: Right hand side in physical space</span>

<span class="sd">        Returns:</span>
<span class="sd">            rhs in physical space with BCs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">rhs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;rhs must not be flattened here!&#39;</span>

        <span class="n">ndim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span>

        <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">):</span>
            <span class="n">_rhs_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="n">axis</span> <span class="o">-</span> <span class="n">ndim</span><span class="p">,))</span>

            <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_BCs</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="n">bc</span><span class="p">[</span><span class="s1">&#39;axis&#39;</span><span class="p">]:</span>
                    <span class="n">_slice</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">bc</span><span class="p">[</span><span class="s1">&#39;equation&#39;</span><span class="p">]),</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">global_slice</span><span class="p">(</span><span class="kc">True</span><span class="p">)]</span>

                    <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">N</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="n">bc</span><span class="p">[</span><span class="s1">&#39;line&#39;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="n">line</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indices</span><span class="p">(</span><span class="kc">True</span><span class="p">)[</span><span class="n">axis</span><span class="p">]:</span>
                        <span class="n">_slice</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="n">line</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_slice</span><span class="p">()[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">start</span>
                        <span class="n">_rhs_hat</span><span class="p">[(</span><span class="o">*</span><span class="n">_slice</span><span class="p">,)]</span> <span class="o">=</span> <span class="n">bc</span><span class="p">[</span><span class="s1">&#39;v&#39;</span><span class="p">]</span>

            <span class="n">rhs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">itransform</span><span class="p">(</span><span class="n">_rhs_hat</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="n">axis</span> <span class="o">-</span> <span class="n">ndim</span><span class="p">,))</span>

        <span class="k">return</span> <span class="n">rhs</span></div>


<div class="viewcode-block" id="SpectralHelper.add_equation_lhs">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.add_equation_lhs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_equation_lhs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">equation</span><span class="p">,</span> <span class="n">relations</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add the left hand part (that you want to solve implicitly) of an equation to a list of lists of sparse matrices</span>
<span class="sd">        that you will convert to an operator later.</span>

<span class="sd">        Example:</span>
<span class="sd">        Setup linear operator `L` for 1D heat equation using Chebychev method in first order form and T-to-U</span>
<span class="sd">        preconditioning:</span>

<span class="sd">        .. code-block:: python</span>
<span class="sd">            helper = SpectralHelper()</span>

<span class="sd">            helper.add_axis(base=&#39;chebychev&#39;, N=8)</span>
<span class="sd">            helper.add_component([&#39;u&#39;, &#39;ux&#39;])</span>
<span class="sd">            helper.setup_fft()</span>

<span class="sd">            I = helper.get_Id()</span>
<span class="sd">            Dx = helper.get_differentiation_matrix(axes=(0,))</span>
<span class="sd">            T2U = helper.get_basis_change_matrix(&#39;T2U&#39;)</span>

<span class="sd">            L_lhs = {</span>
<span class="sd">                &#39;ux&#39;: {&#39;u&#39;: -T2U @ Dx, &#39;ux&#39;: T2U @ I},</span>
<span class="sd">                &#39;u&#39;: {&#39;ux&#39;: -(T2U @ Dx)},</span>
<span class="sd">            }</span>

<span class="sd">            operator = helper.get_empty_operator_matrix()</span>
<span class="sd">            for line, equation in L_lhs.items():</span>
<span class="sd">                helper.add_equation_lhs(operator, line, equation)</span>

<span class="sd">            L = helper.convert_operator_matrix_to_operator(operator)</span>

<span class="sd">        Args:</span>
<span class="sd">            A (list of lists of sparse matrices): The operator to be</span>
<span class="sd">            equation (str): The equation of the component you want this in</span>
<span class="sd">            relations: (dict): Relations between quantities</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">relations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">A</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">equation</span><span class="p">)][</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="n">v</span></div>


<div class="viewcode-block" id="SpectralHelper.eliminate_zeros">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.eliminate_zeros">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">eliminate_zeros</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Eliminate zeros from sparse matrix. This can reduce memory footprint of matrices somewhat.</span>
<span class="sd">        Note: At the time of writing, there are memory problems in the cupy implementation of `eliminate_zeros`.</span>
<span class="sd">        Therefore, this function copies the matrix to host, eliminates the zeros there and then copies back to GPU.</span>

<span class="sd">        Args:</span>
<span class="sd">            A: sparse matrix to be pruned</span>

<span class="sd">        Returns:</span>
<span class="sd">            CSC sparse matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">useGPU</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span>
        <span class="n">A</span><span class="o">.</span><span class="n">eliminate_zeros</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">useGPU</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_lib</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">A</span></div>


<div class="viewcode-block" id="SpectralHelper.convert_operator_matrix_to_operator">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.convert_operator_matrix_to_operator">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">convert_operator_matrix_to_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Promote the list of lists of sparse matrices to a single sparse matrix that can be used as linear operator.</span>
<span class="sd">        See documentation of `SpectralHelper.add_equation_lhs` for an example.</span>

<span class="sd">        Args:</span>
<span class="sd">            M (list of lists of sparse matrices): The operator to be</span>

<span class="sd">        Returns:</span>
<span class="sd">            sparse linear operator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_lib</span><span class="o">.</span><span class="n">bmat</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;csc&#39;</span><span class="p">)</span>

        <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eliminate_zeros</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">op</span></div>


<div class="viewcode-block" id="SpectralHelper.get_wavenumbers">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.get_wavenumbers">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_wavenumbers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get grid in spectral space</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grids</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_wavenumbers</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">local_slice</span><span class="p">(</span><span class="kc">True</span><span class="p">)[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">))]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">grids</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpectralHelper.get_grid">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.get_grid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forward_output</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get grid in physical space</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grids</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_1dgrid</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">local_slice</span><span class="p">(</span><span class="n">forward_output</span><span class="p">)[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">))]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">grids</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpectralHelper.get_indices">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.get_indices">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forward_output</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">N</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">local_slice</span><span class="p">(</span><span class="n">forward_output</span><span class="p">)[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">))]</span></div>


<div class="viewcode-block" id="SpectralHelper.get_pfft">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.get_pfft">[docs]</a>
    <span class="nd">@cache</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_pfft</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">mpi4py_fft</span><span class="w"> </span><span class="kn">import</span> <span class="n">PFFT</span>

        <span class="n">axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span> <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">axes</span>
        <span class="n">padding</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">padding</span> <span class="k">if</span> <span class="n">padding</span> <span class="k">else</span> <span class="p">[</span><span class="mf">1.0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)])</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">no_transform</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">u</span>

        <span class="n">transforms</span> <span class="o">=</span> <span class="p">{(</span><span class="n">i</span><span class="p">,):</span> <span class="p">(</span><span class="n">no_transform</span><span class="p">,</span> <span class="n">no_transform</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
            <span class="n">transforms</span><span class="p">[((</span><span class="n">i</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">,)]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">transform</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">itransform</span><span class="p">)</span>

        <span class="c1"># &quot;transform&quot; all axes to ensure consistent shapes.</span>
        <span class="c1"># Transform non-distributable axes last to ensure they are aligned</span>
        <span class="n">_axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="n">axis</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">))</span>
        <span class="n">_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">axis</span> <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">_axes</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">distributable</span><span class="p">]</span> <span class="o">+</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="p">[</span><span class="n">axis</span> <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">_axes</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">distributable</span><span class="p">]</span>
            <span class="o">+</span> <span class="p">[</span><span class="n">axis</span> <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="k">if</span> <span class="n">axis</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_axes</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">pfft</span> <span class="o">=</span> <span class="n">PFFT</span><span class="p">(</span>
            <span class="n">comm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">global_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
            <span class="n">axes</span><span class="o">=</span><span class="n">_axes</span><span class="p">,</span>  <span class="c1"># TODO: control the order of the transforms better</span>
            <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">,</span>
            <span class="n">collapse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">backend</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fft_backend</span><span class="p">,</span>
            <span class="n">comm_backend</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fft_comm_backend</span><span class="p">,</span>
            <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">,</span>
            <span class="n">transforms</span><span class="o">=</span><span class="n">transforms</span><span class="p">,</span>
            <span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">pfft</span></div>


<div class="viewcode-block" id="SpectralHelper.get_fft">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.get_fft">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_fft</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;object&#39;</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        When using MPI, we use `PFFT` objects generated by mpi4py-fft</span>

<span class="sd">        Args:</span>
<span class="sd">            axes (tuple): Axes you want to transform over</span>
<span class="sd">            direction (str): use &quot;forward&quot; or &quot;backward&quot; to get functions for performing the transforms or &quot;object&quot; to get the PFFT object</span>
<span class="sd">            padding (tuple): Padding for dealiasing</span>
<span class="sd">            shape (tuple): Shape of the transform</span>

<span class="sd">        Returns:</span>
<span class="sd">            transform</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="o">-</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span> <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">axes</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">shape</span>
        <span class="n">padding</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">[</span>
                <span class="mi">1</span><span class="p">,</span>
            <span class="p">]</span>
            <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span>
            <span class="k">if</span> <span class="n">padding</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">padding</span>
        <span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">padding</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fft_cache</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">padding</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;Zero padding is not implemented for non-MPI transforms&#39;</span>

                <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;forward&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fft_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span>
                <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;backward&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fft_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span>
                <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;object&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fft_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;object&#39;</span><span class="p">:</span>
                    <span class="kn">from</span><span class="w"> </span><span class="nn">mpi4py_fft</span><span class="w"> </span><span class="kn">import</span> <span class="n">PFFT</span>

                    <span class="n">_fft</span> <span class="o">=</span> <span class="n">PFFT</span><span class="p">(</span>
                        <span class="n">comm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
                        <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                        <span class="n">axes</span><span class="o">=</span><span class="nb">sorted</span><span class="p">(</span><span class="n">axes</span><span class="p">),</span>
                        <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;D&#39;</span><span class="p">,</span>
                        <span class="n">collapse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">backend</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fft_backend</span><span class="p">,</span>
                        <span class="n">comm_backend</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fft_comm_backend</span><span class="p">,</span>
                        <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_fft</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fft</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;object&#39;</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;forward&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fft_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">_fft</span><span class="o">.</span><span class="n">forward</span>
                <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;backward&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fft_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">_fft</span><span class="o">.</span><span class="n">backward</span>
                <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;object&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fft_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">_fft</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fft_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div>


<div class="viewcode-block" id="SpectralHelper.local_slice">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.local_slice">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">local_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forward_output</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fft_obj</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pfft</span><span class="p">()</span><span class="o">.</span><span class="n">local_slice</span><span class="p">(</span><span class="n">forward_output</span><span class="o">=</span><span class="n">forward_output</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">me</span><span class="o">.</span><span class="n">N</span><span class="p">)</span> <span class="k">for</span> <span class="n">me</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">]</span></div>


<div class="viewcode-block" id="SpectralHelper.global_slice">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.global_slice">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">global_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forward_output</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fft_obj</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">me</span><span class="p">)</span> <span class="k">for</span> <span class="n">me</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fft_obj</span><span class="o">.</span><span class="n">global_shape</span><span class="p">(</span><span class="n">forward_output</span><span class="o">=</span><span class="n">forward_output</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_slice</span><span class="p">(</span><span class="n">forward_output</span><span class="o">=</span><span class="n">forward_output</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpectralHelper.setup_fft">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.setup_fft">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_fft</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">real_spectral_coefficients</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function must be called after all axes have been setup in order to prepare the local shapes of the data.</span>
<span class="sd">        This must also be called before setting up any BCs.</span>

<span class="sd">        Args:</span>
<span class="sd">            real_spectral_coefficients (bool): Allow only real coefficients in spectral space</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_component</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">global_shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">),)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">me</span><span class="o">.</span><span class="n">N</span> <span class="k">for</span> <span class="n">me</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>

        <span class="n">axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fft_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pfft</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">init</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">global_shape</span><span class="p">)[</span>
                <span class="p">(</span>
                    <span class="o">...</span><span class="p">,</span>
                    <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">local_slice</span><span class="p">(</span><span class="kc">False</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_physical</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">global_shape</span><span class="p">)[</span>
                <span class="p">(</span>
                    <span class="o">...</span><span class="p">,</span>
                    <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">local_slice</span><span class="p">(</span><span class="kc">False</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_forward</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">global_shape</span><span class="p">)[</span>
                <span class="p">(</span>
                    <span class="o">...</span><span class="p">,</span>
                    <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">local_slice</span><span class="p">(</span><span class="kc">True</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">real_spectral_coefficients</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;complex128&#39;</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">BC_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_empty_operator_matrix</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BC_rhs_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">newDistArray</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpectralHelper.newDistArray">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.newDistArray">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">newDistArray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pfft</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">forward_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">view</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get an empty distributed array. This is almost a copy of the function of the same name from mpi4py-fft, but</span>
<span class="sd">        takes care of all the solution components in the tensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">init</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">init</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">mpi4py_fft.distarray</span><span class="w"> </span><span class="kn">import</span> <span class="n">DistArray</span>

        <span class="n">pfft</span> <span class="o">=</span> <span class="n">pfft</span> <span class="k">if</span> <span class="n">pfft</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pfft</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">pfft</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">forward_output</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_init_forward</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_init</span>

        <span class="n">global_shape</span> <span class="o">=</span> <span class="n">pfft</span><span class="o">.</span><span class="n">global_shape</span><span class="p">(</span><span class="n">forward_output</span><span class="p">)</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="n">pfft</span><span class="o">.</span><span class="n">pencil</span><span class="p">[</span><span class="n">forward_output</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">forward_output</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">pfft</span><span class="o">.</span><span class="n">forward</span><span class="o">.</span><span class="n">output_array</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">pfft</span><span class="o">.</span><span class="n">forward</span><span class="o">.</span><span class="n">input_array</span><span class="o">.</span><span class="n">dtype</span>
        <span class="n">global_shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomponents</span><span class="p">,)</span> <span class="o">*</span> <span class="n">rank</span> <span class="o">+</span> <span class="n">global_shape</span>

        <span class="k">if</span> <span class="n">pfft</span><span class="o">.</span><span class="n">xfftn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">backend</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;cupy&quot;</span><span class="p">,</span> <span class="s2">&quot;cupyx-scipy&quot;</span><span class="p">]:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">mpi4py_fft.distarrayCuPy</span><span class="w"> </span><span class="kn">import</span> <span class="n">DistArrayCuPy</span> <span class="k">as</span> <span class="n">darraycls</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">darraycls</span> <span class="o">=</span> <span class="n">DistArray</span>

        <span class="n">z</span> <span class="o">=</span> <span class="n">darraycls</span><span class="p">(</span><span class="n">global_shape</span><span class="p">,</span> <span class="n">subcomm</span><span class="o">=</span><span class="n">p0</span><span class="o">.</span><span class="n">subcomm</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">val</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">alignment</span><span class="o">=</span><span class="n">p0</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="n">rank</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">z</span><span class="o">.</span><span class="n">v</span> <span class="k">if</span> <span class="n">view</span> <span class="k">else</span> <span class="n">z</span></div>


<div class="viewcode-block" id="SpectralHelper.infer_alignment">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.infer_alignment">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">infer_alignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">forward_output</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_alignment</span><span class="p">(</span><span class="n">pfft</span><span class="p">):</span>
            <span class="n">_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">newDistArray</span><span class="p">(</span><span class="n">pfft</span><span class="p">,</span> <span class="n">forward_output</span><span class="o">=</span><span class="n">forward_output</span><span class="p">)</span>
            <span class="n">_aligned_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="k">if</span> <span class="n">_arr</span><span class="o">.</span><span class="n">global_shape</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
            <span class="k">return</span> <span class="n">_aligned_axes</span>

        <span class="k">if</span> <span class="n">padding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pfft</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pfft</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">aligned_axes</span> <span class="o">=</span> <span class="n">_alignment</span><span class="p">(</span><span class="n">pfft</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">padding_options</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">padding</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">padding</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">padding</span><span class="p">,</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">padding_options</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">padding</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                    <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">padding</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">),</span>
                    <span class="p">(</span><span class="n">padding</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
                    <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">padding</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">padding</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                    <span class="p">(</span><span class="n">padding</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">padding</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                    <span class="p">(</span><span class="n">padding</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">padding</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">),</span>
                    <span class="n">padding</span><span class="p">,</span>
                    <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
                <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Don</span><span class="se">\&#39;</span><span class="s1">t know how to infer alignment in </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s1">D!&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">_padding</span> <span class="ow">in</span> <span class="n">padding_options</span><span class="p">:</span>
                <span class="n">pfft</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pfft</span><span class="p">(</span><span class="n">padding</span><span class="o">=</span><span class="n">_padding</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="n">aligned_axes</span> <span class="o">=</span> <span class="n">_alignment</span><span class="p">(</span><span class="n">pfft</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">aligned_axes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s1">&#39;Found alignment of array with size </span><span class="si">{</span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">aligned_axes</span><span class="si">}</span><span class="s1"> using padding </span><span class="si">{</span><span class="n">_padding</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="p">)</span>
                    <span class="k">break</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">aligned_axes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;Found no aligned axes for array of size </span><span class="si">{</span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">!&#39;</span>
        <span class="k">return</span> <span class="n">aligned_axes</span></div>


<div class="viewcode-block" id="SpectralHelper.redistribute">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.redistribute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">redistribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">forward_output</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">u</span>

        <span class="n">pfft</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pfft</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">newDistArray</span><span class="p">(</span><span class="n">pfft</span><span class="p">,</span> <span class="n">forward_output</span><span class="o">=</span><span class="n">forward_output</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;Dist&#39;</span> <span class="ow">in</span> <span class="nb">type</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">and</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">u</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="n">_arr</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">_arr</span>
            <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="n">u_alignment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">infer_alignment</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">forward_output</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">alignment</span> <span class="ow">in</span> <span class="n">u_alignment</span><span class="p">:</span>
            <span class="n">_arr</span> <span class="o">=</span> <span class="n">_arr</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="n">alignment</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_arr</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="n">_arr</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
                <span class="k">return</span> <span class="n">_arr</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;Don</span><span class="se">\&#39;</span><span class="s1">t know how to align array of local shape </span><span class="si">{</span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1"> and global shape </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">global_shape</span><span class="si">}</span><span class="s1">, aligned in axes </span><span class="si">{</span><span class="n">u_alignment</span><span class="si">}</span><span class="s1">, to axis </span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="SpectralHelper.transform">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.transform">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">pfft</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pfft</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pfft</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="n">axes</span> <span class="k">if</span> <span class="n">axes</span> <span class="k">else</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
            <span class="n">u_hat</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
                <span class="n">_axis</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">i</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">i</span>
                <span class="n">u_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">u_hat</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="n">_axis</span><span class="p">,))</span>
            <span class="k">return</span> <span class="n">u_hat</span>

        <span class="n">_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">newDistArray</span><span class="p">(</span><span class="n">pfft</span><span class="p">,</span> <span class="n">forward_output</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">newDistArray</span><span class="p">(</span><span class="n">pfft</span><span class="p">,</span> <span class="n">forward_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_in</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="n">_in</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_in</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">_in</span><span class="o">.</span><span class="n">alignment</span><span class="p">,</span> <span class="n">forward_output</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomponents</span><span class="p">):</span>
            <span class="n">pfft</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">_in</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">_out</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">padding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_out</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">padding</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_out</span></div>


<div class="viewcode-block" id="SpectralHelper.itransform">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.itransform">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">itransform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">padding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">N</span> <span class="o">*</span> <span class="n">padding</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">%</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
            <span class="p">),</span> <span class="s1">&#39;Cannot do this padding with this resolution. Resulting resolution must be integer&#39;</span>

        <span class="n">pfft</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pfft</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pfft</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="n">axes</span> <span class="k">if</span> <span class="n">axes</span> <span class="k">else</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
            <span class="n">u_hat</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
                <span class="n">_axis</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">i</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">i</span>
                <span class="n">u_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">itransform</span><span class="p">(</span><span class="n">u_hat</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="n">_axis</span><span class="p">,))</span>
            <span class="k">return</span> <span class="n">u_hat</span>

        <span class="n">_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">newDistArray</span><span class="p">(</span><span class="n">pfft</span><span class="p">,</span> <span class="n">forward_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">newDistArray</span><span class="p">(</span><span class="n">pfft</span><span class="p">,</span> <span class="n">forward_output</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_in</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="n">_in</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_in</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">_in</span><span class="o">.</span><span class="n">alignment</span><span class="p">,</span> <span class="n">forward_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomponents</span><span class="p">):</span>
            <span class="n">pfft</span><span class="o">.</span><span class="n">backward</span><span class="p">(</span><span class="n">_in</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">_out</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">padding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_out</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">padding</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_out</span></div>


<div class="viewcode-block" id="SpectralHelper.get_local_slice_of_1D_matrix">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.get_local_slice_of_1D_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_local_slice_of_1D_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the local version of a 1D matrix. When using distributed FFTs, each rank will carry only a subset of modes,</span>
<span class="sd">        which you can sort out via the `SpectralHelper.local_slice()` attribute. When constructing a 1D matrix, you can</span>
<span class="sd">        use this method to get the part corresponding to the modes carried by this rank.</span>

<span class="sd">        Args:</span>
<span class="sd">            M (sparse matrix): Global 1D matrix you want to get the local version of</span>
<span class="sd">            axis (int): Direction in which you want the local version. You will get the global matrix in other directions.</span>

<span class="sd">        Returns:</span>
<span class="sd">            sparse local matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">M</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">local_slice</span><span class="p">(</span><span class="kc">True</span><span class="p">)[</span><span class="n">axis</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_slice</span><span class="p">(</span><span class="kc">True</span><span class="p">)[</span><span class="n">axis</span><span class="p">]]</span></div>


<div class="viewcode-block" id="SpectralHelper.expand_matrix_ND">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.expand_matrix_ND">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">expand_matrix_ND</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">aligned</span><span class="p">):</span>
        <span class="n">sp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_lib</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">),</span> <span class="n">aligned</span><span class="p">)</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">matrix</span>
        <span class="k">elif</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">I1D</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>

            <span class="n">mats</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">ndim</span>
            <span class="n">mats</span><span class="p">[</span><span class="n">aligned</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_local_slice_of_1D_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">aligned</span><span class="p">)</span>
            <span class="n">mats</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_local_slice_of_1D_matrix</span><span class="p">(</span><span class="n">I1D</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

            <span class="n">mat</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="o">*</span><span class="n">mats</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>

            <span class="n">mats</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">ndim</span>
            <span class="n">mats</span><span class="p">[</span><span class="n">aligned</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_local_slice_of_1D_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">aligned</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
                <span class="n">I1D</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
                <span class="n">mats</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_local_slice_of_1D_matrix</span><span class="p">(</span><span class="n">I1D</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

            <span class="n">mat</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">mats</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sp</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="o">*</span><span class="n">mats</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Matrix expansion not implemented for </span><span class="si">{</span><span class="n">ndim</span><span class="si">}</span><span class="s1"> dimensions!&#39;</span><span class="p">)</span>

        <span class="n">mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eliminate_zeros</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mat</span></div>


<div class="viewcode-block" id="SpectralHelper.get_filter_matrix">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.get_filter_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_filter_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get bandpass filter along `axis`. See the documentation `get_filter_matrix` in the 1D bases for what kwargs are</span>
<span class="sd">        admissible.</span>

<span class="sd">        Returns:</span>
<span class="sd">            sparse bandpass matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_filter_matrix</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">mats</span> <span class="o">=</span> <span class="p">[</span><span class="n">base</span><span class="o">.</span><span class="n">get_Id</span><span class="p">()</span> <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">]</span>
        <span class="n">mats</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">get_filter_matrix</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_lib</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="o">*</span><span class="n">mats</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpectralHelper.get_differentiation_matrix">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.get_differentiation_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_differentiation_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get differentiation matrix along specified axis. `kwargs` are forwarded to the 1D base implementation.</span>

<span class="sd">        Args:</span>
<span class="sd">            axes (tuple): Axes along which to differentiate.</span>

<span class="sd">        Returns:</span>
<span class="sd">            sparse differentiation matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand_matrix_ND</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">get_differentiation_matrix</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">_D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">get_differentiation_matrix</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">D</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand_matrix_ND</span><span class="p">(</span><span class="n">_D</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">D</span></div>


<div class="viewcode-block" id="SpectralHelper.get_integration_matrix">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.get_integration_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_integration_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get integration matrix to integrate along specified axis.</span>

<span class="sd">        Args:</span>
<span class="sd">            axes (tuple): Axes along which to integrate over.</span>

<span class="sd">        Returns:</span>
<span class="sd">            sparse integration matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand_matrix_ND</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">get_integration_matrix</span><span class="p">(),</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">_S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">get_integration_matrix</span><span class="p">()</span>
            <span class="n">S</span> <span class="o">=</span> <span class="n">S</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand_matrix_ND</span><span class="p">(</span><span class="n">_S</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">S</span></div>


<div class="viewcode-block" id="SpectralHelper.get_Id">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.get_Id">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_Id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get identity matrix</span>

<span class="sd">        Returns:</span>
<span class="sd">            sparse identity matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">I</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand_matrix_ND</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_Id</span><span class="p">(),</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
            <span class="n">_I</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">get_Id</span><span class="p">()</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">I</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand_matrix_ND</span><span class="p">(</span><span class="n">_I</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">I</span></div>


<div class="viewcode-block" id="SpectralHelper.get_Dirichlet_recombination_matrix">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.get_Dirichlet_recombination_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_Dirichlet_recombination_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get Dirichlet recombination matrix along axis. Not that it only makes sense in directions discretized with variations of Chebychev bases.</span>

<span class="sd">        Args:</span>
<span class="sd">            axis (int): Axis you discretized with Chebychev</span>

<span class="sd">        Returns:</span>
<span class="sd">            sparse matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">C1D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">get_Dirichlet_recombination_matrix</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand_matrix_ND</span><span class="p">(</span><span class="n">C1D</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span></div>


<div class="viewcode-block" id="SpectralHelper.get_basis_change_matrix">
<a class="viewcode-back" href="../../pySDC/helpers.spectral_helper.html#helpers.spectral_helper.SpectralHelper.get_basis_change_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_basis_change_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Some spectral bases do a change between bases while differentiating. This method returns matrices that changes the basis to whatever you want.</span>
<span class="sd">        Refer to the methods of the same name of the 1D bases to learn what parameters you need to pass here as `kwargs`.</span>

<span class="sd">        Args:</span>
<span class="sd">            axes (tuple): Axes along which to change basis.</span>

<span class="sd">        Returns:</span>
<span class="sd">            sparse basis change matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="o">-</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span> <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">axes</span>

        <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand_matrix_ND</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">get_basis_change_matrix</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">_C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">get_basis_change_matrix</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">C</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand_matrix_ND</span><span class="p">(</span><span class="n">_C</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">C</span></div>
</div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">pySDC 5.6 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">helpers.spectral_helper</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2024, Robert Speck.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3.
    </div>
  </body>
</html>