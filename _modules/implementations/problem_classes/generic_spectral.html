<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>implementations.problem_classes.generic_spectral &#8212; pySDC 5.6 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/classic.css?v=2bf1fcf8" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom.css?v=c40552b6" />
    
    <script src="../../../_static/documentation_options.js?v=81710850"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">pySDC 5.6 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">implementations.problem_classes.generic_spectral</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for implementations.problem_classes.generic_spectral</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span><span class="w"> </span><span class="nn">pySDC.core.problem</span><span class="w"> </span><span class="kn">import</span> <span class="n">Problem</span><span class="p">,</span> <span class="n">WorkCounter</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pySDC.helpers.spectral_helper</span><span class="w"> </span><span class="kn">import</span> <span class="n">SpectralHelper</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pySDC.core.errors</span><span class="w"> </span><span class="kn">import</span> <span class="n">ParameterError</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pySDC.helpers.fieldsIO</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rectilinear</span>


<div class="viewcode-block" id="GenericSpectralLinear">
<a class="viewcode-back" href="../../../pySDC/implementations.problem_classes.generic_spectral.html#implementations.problem_classes.generic_spectral.GenericSpectralLinear">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">GenericSpectralLinear</span><span class="p">(</span><span class="n">Problem</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generic class to solve problems of the form M u_t + L u = y, with mass matrix M, linear operator L and some right</span>
<span class="sd">    hand side y using spectral methods.</span>
<span class="sd">    L may contain algebraic conditions, as long as (M + dt L) is invertible.</span>

<span class="sd">    Note that the `__getattr__` method is overloaded to pass requests on to the spectral helper if they are not</span>
<span class="sd">    attributes of this class itself. For instance, you can add a BC by calling `self.spectral.add_BC` or equivalently</span>
<span class="sd">    `self.add_BC`.</span>

<span class="sd">    You can port problems derived from this more or less seamlessly to GPU by using the numerical libraries that are</span>
<span class="sd">    class attributes of the spectral helper. This class will automatically switch the datatype using the `setup_GPU` class method.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        spectral (pySDC.helpers.spectral_helper.SpectralHelper): Spectral helper</span>
<span class="sd">        work_counters (dict): Dictionary for counting work</span>
<span class="sd">        cached_factorizations (dict): Dictionary of cached matrix factorizations for solving</span>
<span class="sd">        L (sparse matrix): Linear operator</span>
<span class="sd">        M (sparse matrix): Mass matrix</span>
<span class="sd">        diff_mask (list): Mask for separating differential and algebraic terms</span>
<span class="sd">        Pl (sparse matrix): Left preconditioner</span>
<span class="sd">        Pr (sparse matrix): Right preconditioner</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="GenericSpectralLinear.setup_GPU">
<a class="viewcode-back" href="../../../pySDC/implementations.problem_classes.generic_spectral.html#implementations.problem_classes.generic_spectral.GenericSpectralLinear.setup_GPU">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_GPU</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;switch to GPU modules&quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">pySDC.implementations.datatype_classes.cupy_mesh</span><span class="w"> </span><span class="kn">import</span> <span class="n">cupy_mesh</span><span class="p">,</span> <span class="n">imex_cupy_mesh</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">pySDC.implementations.datatype_classes.mesh</span><span class="w"> </span><span class="kn">import</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">imex_mesh</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dtype_u</span> <span class="o">=</span> <span class="n">cupy_mesh</span>

        <span class="n">GPU_versions</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">mesh</span><span class="p">:</span> <span class="n">cupy_mesh</span><span class="p">,</span>
            <span class="n">imex_mesh</span><span class="p">:</span> <span class="n">imex_cupy_mesh</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dtype_f</span> <span class="o">=</span> <span class="n">GPU_versions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype_f</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">pySDC.helpers.NCCL_communicator</span><span class="w"> </span><span class="kn">import</span> <span class="n">NCCLComm</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span> <span class="n">NCCLComm</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;comm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">NCCLComm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">bases</span><span class="p">,</span>
        <span class="n">components</span><span class="p">,</span>
        <span class="n">comm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">Dirichlet_recombination</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">left_preconditioner</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">solver_type</span><span class="o">=</span><span class="s1">&#39;cached_direct&#39;</span><span class="p">,</span>
        <span class="n">solver_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">useGPU</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">max_cached_factorizations</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span>
        <span class="n">spectral_space</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">real_spectral_coefficients</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Base class for problems discretized with spectral methods.</span>

<span class="sd">        Args:</span>
<span class="sd">            bases (list of dictionaries): 1D Bases</span>
<span class="sd">            components (list of strings): Components of the equations</span>
<span class="sd">            comm (mpi4py.Intracomm or None): MPI communicator</span>
<span class="sd">            Dirichlet_recombination (bool): Use Dirichlet recombination in the last axis as right preconditioner</span>
<span class="sd">            left_preconditioner (bool): Reverse the Kronecker product if yes</span>
<span class="sd">            solver_type (str): Solver for linear systems</span>
<span class="sd">            solver_args (dict): Arguments for linear solver</span>
<span class="sd">            useGPU (bool): Run on GPU or CPU</span>
<span class="sd">            max_cached_factorizations (int): Number of matrix decompositions to cache before starting eviction</span>
<span class="sd">            spectral_space (bool): If yes, the solution will not be transformed back after solving and evaluating the RHS, and is expected as input in spectral space to these functions</span>
<span class="sd">            real_spectral_coefficients (bool): If yes, allow only real values in spectral space, otherwise, allow complex.</span>
<span class="sd">            debug (bool): Make additional tests at extra computational cost</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">solver_args</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">solver_args</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">solver_args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_makeAttributeAndRegister</span><span class="p">(</span>
            <span class="s1">&#39;max_cached_factorizations&#39;</span><span class="p">,</span>
            <span class="s1">&#39;useGPU&#39;</span><span class="p">,</span>
            <span class="s1">&#39;solver_type&#39;</span><span class="p">,</span>
            <span class="s1">&#39;solver_args&#39;</span><span class="p">,</span>
            <span class="s1">&#39;left_preconditioner&#39;</span><span class="p">,</span>
            <span class="s1">&#39;Dirichlet_recombination&#39;</span><span class="p">,</span>
            <span class="s1">&#39;comm&#39;</span><span class="p">,</span>
            <span class="s1">&#39;spectral_space&#39;</span><span class="p">,</span>
            <span class="s1">&#39;real_spectral_coefficients&#39;</span><span class="p">,</span>
            <span class="s1">&#39;debug&#39;</span><span class="p">,</span>
            <span class="n">localVars</span><span class="o">=</span><span class="nb">locals</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span> <span class="o">=</span> <span class="n">SpectralHelper</span><span class="p">(</span><span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">,</span> <span class="n">useGPU</span><span class="o">=</span><span class="n">useGPU</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">useGPU</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setup_GPU</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="s1">&#39;rtol&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_args</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">solver_args</span><span class="p">[</span><span class="s1">&#39;tol&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_args</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;rtol&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="o">.</span><span class="n">add_axis</span><span class="p">(</span><span class="o">**</span><span class="n">base</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="o">.</span><span class="n">add_component</span><span class="p">(</span><span class="n">components</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="o">.</span><span class="n">setup_fft</span><span class="p">(</span><span class="n">real_spectral_coefficients</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="o">.</span><span class="n">init_forward</span> <span class="k">if</span> <span class="n">spectral_space</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="o">.</span><span class="n">init</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">work_counters</span><span class="p">[</span><span class="n">solver_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">WorkCounter</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">work_counters</span><span class="p">[</span><span class="s1">&#39;factorizations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WorkCounter</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">setup_preconditioner</span><span class="p">(</span><span class="n">Dirichlet_recombination</span><span class="p">,</span> <span class="n">left_preconditioner</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cached_factorizations</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pass requests on to the helper if they are not directly attributes of this class for convenience.</span>

<span class="sd">        Args:</span>
<span class="sd">            name (str): Name of the attribute you want</span>

<span class="sd">        Returns:</span>
<span class="sd">            request</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_setup_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">LHS</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setup a sparse linear operator by adding relationships. See documentation for ``GenericSpectralLinear.setup_L`` to learn more.</span>

<span class="sd">        Args:</span>
<span class="sd">            LHS (dict): Equations to be added to the operator</span>

<span class="sd">        Returns:</span>
<span class="sd">            sparse linear operator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">operator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="o">.</span><span class="n">get_empty_operator_matrix</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">line</span><span class="p">,</span> <span class="n">equation</span> <span class="ow">in</span> <span class="n">LHS</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="o">.</span><span class="n">add_equation_lhs</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">equation</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="o">.</span><span class="n">convert_operator_matrix_to_operator</span><span class="p">(</span><span class="n">operator</span><span class="p">)</span>

<div class="viewcode-block" id="GenericSpectralLinear.setup_L">
<a class="viewcode-back" href="../../../pySDC/implementations.problem_classes.generic_spectral.html#implementations.problem_classes.generic_spectral.GenericSpectralLinear.setup_L">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_L</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">LHS</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setup the left hand side of the linear operator L and store it in ``self.L``.</span>

<span class="sd">        The argument is meant to be a dictionary with the line you want to write the equation in as the key and the relationship between components as another dictionary. For instance, you can add an algebraic condition capturing a first derivative relationship between u and ux as follows:</span>

<span class="sd">        ```</span>
<span class="sd">        Dx = self.get_differentiation_matrix(axes=(0,))</span>
<span class="sd">        I = self.get_Id()</span>
<span class="sd">        LHS = {&#39;ux&#39;: {&#39;u&#39;: Dx, &#39;ux&#39;: -I}}</span>
<span class="sd">        self.setup_L(LHS)</span>
<span class="sd">        ```</span>

<span class="sd">        If you put zero as right hand side for the solver in the line for ux, ux will contain the x-derivative of u afterwards.</span>

<span class="sd">        Args:</span>
<span class="sd">            LHS (dict): Dictionary containing the equations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setup_operator</span><span class="p">(</span><span class="n">LHS</span><span class="p">)</span></div>


<div class="viewcode-block" id="GenericSpectralLinear.setup_M">
<a class="viewcode-back" href="../../../pySDC/implementations.problem_classes.generic_spectral.html#implementations.problem_classes.generic_spectral.GenericSpectralLinear.setup_M">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_M</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">LHS</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Setup mass matrix, see documentation of ``GenericSpectralLinear.setup_L``.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">diff_index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">LHS</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diff_mask</span> <span class="o">=</span> <span class="p">[</span><span class="n">me</span> <span class="ow">in</span> <span class="n">diff_index</span> <span class="k">for</span> <span class="n">me</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setup_operator</span><span class="p">(</span><span class="n">LHS</span><span class="p">)</span></div>


<div class="viewcode-block" id="GenericSpectralLinear.setup_preconditioner">
<a class="viewcode-back" href="../../../pySDC/implementations.problem_classes.generic_spectral.html#implementations.problem_classes.generic_spectral.GenericSpectralLinear.setup_preconditioner">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_preconditioner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Dirichlet_recombination</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">left_preconditioner</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get left and right preconditioners.</span>

<span class="sd">        Args:</span>
<span class="sd">            Dirichlet_recombination (bool): Basis conversion for right preconditioner. Useful for Chebychev and Ultraspherical methods. 10/10 would recommend.</span>
<span class="sd">            left_preconditioner (bool): If True, it will interleave the variables and reverse the Kronecker product</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="o">.</span><span class="n">sparse_lib</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">init</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:])</span>

        <span class="n">Id</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="n">Pl_lhs</span> <span class="o">=</span> <span class="p">{</span><span class="n">comp</span><span class="p">:</span> <span class="p">{</span><span class="n">comp</span><span class="p">:</span> <span class="n">Id</span><span class="p">}</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Pl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setup_operator</span><span class="p">(</span><span class="n">Pl_lhs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">left_preconditioner</span><span class="p">:</span>
            <span class="c1"># reverse Kronecker product</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="o">.</span><span class="n">useGPU</span><span class="p">:</span>
                <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Pl</span><span class="o">.</span><span class="n">get</span><span class="p">()</span><span class="o">.</span><span class="n">tolil</span><span class="p">()</span> <span class="o">*</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Pl</span><span class="o">.</span><span class="n">tolil</span><span class="p">()</span> <span class="o">*</span> <span class="mi">0</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomponents</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                    <span class="n">R</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncomponents</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">j</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">Pl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="o">.</span><span class="n">sparse_lib</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">Dirichlet_recombination</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ChebychevHelper, Ultraspherical&#39;</span><span class="p">]:</span>
            <span class="n">_Pr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="o">.</span><span class="n">get_Dirichlet_recombination_matrix</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_Pr</span> <span class="o">=</span> <span class="n">Id</span>

        <span class="n">Pr_lhs</span> <span class="o">=</span> <span class="p">{</span><span class="n">comp</span><span class="p">:</span> <span class="p">{</span><span class="n">comp</span><span class="p">:</span> <span class="n">_Pr</span><span class="p">}</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Pr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setup_operator</span><span class="p">(</span><span class="n">Pr_lhs</span><span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">Pl</span><span class="o">.</span><span class="n">T</span></div>


<div class="viewcode-block" id="GenericSpectralLinear.solve_system">
<a class="viewcode-back" href="../../../pySDC/implementations.problem_classes.generic_spectral.html#implementations.problem_classes.generic_spectral.GenericSpectralLinear.solve_system">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">solve_system</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">u0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">skip_itransform</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Do an implicit Euler step to solve M u_t + Lu = rhs, with M the mass matrix and L the linear operator as setup by</span>
<span class="sd">        ``GenericSpectralLinear.setup_L`` and ``GenericSpectralLinear.setup_M``.</span>

<span class="sd">        The implicit Euler step is (M - dt L) u = M rhs. Note that M need not be invertible as long as (M + dt*L) is.</span>
<span class="sd">        This means solving with dt=0 to mimic explicit methods does not work for all problems, in particular simple DAEs.</span>

<span class="sd">        Note that by putting M rhs on the right hand side, this function can only solve algebraic conditions equal to</span>
<span class="sd">        zero. If you want something else, it should be easy to overload this function.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">sp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="o">.</span><span class="n">sparse_lib</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_space</span><span class="p">:</span>
            <span class="n">rhs_hat</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">u0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">u0_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Pr</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">u0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rhs_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">u0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">u0_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Pr</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">u0</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">useGPU</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">Device</span><span class="p">()</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>

        <span class="n">rhs_hat</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">@</span> <span class="n">rhs_hat</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">rhs_hat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">rhs_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="o">.</span><span class="n">put_BCs_in_rhs_hat</span><span class="p">(</span><span class="n">rhs_hat</span><span class="p">)</span>
        <span class="n">rhs_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Pl</span> <span class="o">@</span> <span class="n">rhs_hat</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">dt</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cached_factorizations</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;cached_direct&#39;</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">+</span> <span class="n">dt</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span>
            <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Pl</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="o">.</span><span class="n">put_BCs_in_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">Pr</span>

        <span class="c1"># import numpy as np</span>
        <span class="c1"># if A.shape[0] &lt; 200:</span>
        <span class="c1">#     import matplotlib.pyplot as plt</span>

        <span class="c1">#     # M = self.spectral.put_BCs_in_matrix(self.L.copy())</span>
        <span class="c1">#     M = A  # self.L</span>
        <span class="c1">#     im = plt.imshow((M / abs(M)).real)</span>
        <span class="c1">#     # im = plt.imshow(np.log10(abs(A.toarray())).real)</span>
        <span class="c1">#     # im = plt.imshow(((A.toarray())).real)</span>
        <span class="c1">#     plt.colorbar(im)</span>
        <span class="c1">#     plt.show()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;cached_direct&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dt</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cached_factorizations</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cached_factorizations</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_cached_factorizations</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cached_factorizations</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cached_factorizations</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Evicted matrix factorization for </span><span class="si">{</span><span class="n">dt</span><span class="si">=:</span><span class="s1">.6f</span><span class="si">}</span><span class="s1"> from cache&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cached_factorizations</span><span class="p">[</span><span class="n">dt</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">factorized</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Cached matrix factorization for </span><span class="si">{</span><span class="n">dt</span><span class="si">=:</span><span class="s1">.6f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">work_counters</span><span class="p">[</span><span class="s1">&#39;factorizations&#39;</span><span class="p">]()</span>

            <span class="n">_sol_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cached_factorizations</span><span class="p">[</span><span class="n">dt</span><span class="p">](</span><span class="n">rhs_hat</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Used cached matrix factorization for </span><span class="si">{</span><span class="n">dt</span><span class="si">=:</span><span class="s1">.6f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;direct&#39;</span><span class="p">:</span>
            <span class="n">_sol_hat</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">rhs_hat</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;lsqr&#39;</span><span class="p">:</span>
            <span class="n">lsqr</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lsqr</span><span class="p">(</span>
                <span class="n">A</span><span class="p">,</span>
                <span class="n">rhs_hat</span><span class="p">,</span>
                <span class="n">x0</span><span class="o">=</span><span class="n">u0_hat</span><span class="p">,</span>
                <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">solver_args</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">_sol_hat</span> <span class="o">=</span> <span class="n">lsqr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;gmres&#39;</span><span class="p">:</span>
            <span class="n">_sol_hat</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">gmres</span><span class="p">(</span>
                <span class="n">A</span><span class="p">,</span>
                <span class="n">rhs_hat</span><span class="p">,</span>
                <span class="n">x0</span><span class="o">=</span><span class="n">u0_hat</span><span class="p">,</span>
                <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">solver_args</span><span class="p">,</span>
                <span class="n">callback</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">work_counters</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">solver_type</span><span class="p">],</span>
                <span class="n">callback_type</span><span class="o">=</span><span class="s1">&#39;pr_norm&#39;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;gmres+ilu&#39;</span><span class="p">:</span>
            <span class="n">linalg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="o">.</span><span class="n">linalg</span>

            <span class="k">if</span> <span class="n">dt</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cached_factorizations</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cached_factorizations</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_cached_factorizations</span><span class="p">:</span>
                    <span class="n">to_evict</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cached_factorizations</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cached_factorizations</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">to_evict</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Evicted matrix factorization for </span><span class="si">{</span><span class="n">to_evict</span><span class="si">=:</span><span class="s1">.6f</span><span class="si">}</span><span class="s1"> from cache&#39;</span><span class="p">)</span>
                <span class="n">iLU</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">spilu</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">drop_tol</span><span class="o">=</span><span class="n">dt</span> <span class="o">*</span> <span class="mf">1e-4</span><span class="p">,</span> <span class="n">fill_factor</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cached_factorizations</span><span class="p">[</span><span class="n">dt</span><span class="p">]</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">LinearOperator</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">iLU</span><span class="o">.</span><span class="n">solve</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Cached matrix factorization for </span><span class="si">{</span><span class="n">dt</span><span class="si">=:</span><span class="s1">.6f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">work_counters</span><span class="p">[</span><span class="s1">&#39;factorizations&#39;</span><span class="p">]()</span>

            <span class="n">_sol_hat</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">gmres</span><span class="p">(</span>
                <span class="n">A</span><span class="p">,</span>
                <span class="n">rhs_hat</span><span class="p">,</span>
                <span class="n">x0</span><span class="o">=</span><span class="n">u0_hat</span><span class="p">,</span>
                <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">solver_args</span><span class="p">,</span>
                <span class="n">callback</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">work_counters</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">solver_type</span><span class="p">],</span>
                <span class="n">callback_type</span><span class="o">=</span><span class="s1">&#39;pr_norm&#39;</span><span class="p">,</span>
                <span class="n">M</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cached_factorizations</span><span class="p">[</span><span class="n">dt</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;cg&#39;</span><span class="p">:</span>
            <span class="n">_sol_hat</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cg</span><span class="p">(</span>
                <span class="n">A</span><span class="p">,</span> <span class="n">rhs_hat</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">u0_hat</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">solver_args</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">work_counters</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">solver_type</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Solver </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">solver_type</span><span class="si">=}</span><span class="s1"> not implemented in </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">!&#39;</span><span class="p">)</span>

        <span class="n">sol_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="o">.</span><span class="n">u_init_forward</span>
        <span class="n">sol_hat</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Pr</span> <span class="o">@</span> <span class="n">_sol_hat</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sol_hat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">useGPU</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">Device</span><span class="p">()</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_space</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sol_hat</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="o">.</span><span class="n">u_init</span>
            <span class="n">sol</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="o">.</span><span class="n">itransform</span><span class="p">(</span><span class="n">sol_hat</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="o">.</span><span class="n">check_BCs</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">sol</span></div>


<div class="viewcode-block" id="GenericSpectralLinear.setUpFieldsIO">
<a class="viewcode-back" href="../../../pySDC/implementations.problem_classes.generic_spectral.html#implementations.problem_classes.generic_spectral.GenericSpectralLinear.setUpFieldsIO">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setUpFieldsIO</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">Rectilinear</span><span class="o">.</span><span class="n">setupMPI</span><span class="p">(</span>
            <span class="n">comm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
            <span class="n">iLoc</span><span class="o">=</span><span class="p">[</span><span class="n">me</span><span class="o">.</span><span class="n">start</span> <span class="k">for</span> <span class="n">me</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_slice</span><span class="p">],</span>
            <span class="n">nLoc</span><span class="o">=</span><span class="p">[</span><span class="n">me</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="n">me</span><span class="o">.</span><span class="n">start</span> <span class="k">for</span> <span class="n">me</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_slice</span><span class="p">],</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="GenericSpectralLinear.getOutputFile">
<a class="viewcode-back" href="../../../pySDC/implementations.problem_classes.generic_spectral.html#implementations.problem_classes.generic_spectral.GenericSpectralLinear.getOutputFile">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getOutputFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileName</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setUpFieldsIO</span><span class="p">()</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">me</span><span class="o">.</span><span class="n">get_1dgrid</span><span class="p">()</span> <span class="k">for</span> <span class="n">me</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="o">.</span><span class="n">axes</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">me</span><span class="p">)</span> <span class="k">for</span> <span class="n">me</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="o">.</span><span class="n">global_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

        <span class="n">fOut</span> <span class="o">=</span> <span class="n">Rectilinear</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">fileName</span><span class="o">=</span><span class="n">fileName</span><span class="p">)</span>
        <span class="n">fOut</span><span class="o">.</span><span class="n">setHeader</span><span class="p">(</span><span class="n">nVar</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">),</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">fOut</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">fOut</span></div>


<div class="viewcode-block" id="GenericSpectralLinear.processSolutionForOutput">
<a class="viewcode-back" href="../../../pySDC/implementations.problem_classes.generic_spectral.html#implementations.problem_classes.generic_spectral.GenericSpectralLinear.processSolutionForOutput">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">processSolutionForOutput</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_space</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">itransform</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">real</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="compute_residual_DAE">
<a class="viewcode-back" href="../../../pySDC/implementations.problem_classes.generic_spectral.html#implementations.problem_classes.generic_spectral.compute_residual_DAE">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_residual_DAE</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stage</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computation of the residual that does not add u_0 - u_m in algebraic equations.</span>

<span class="sd">    Args:</span>
<span class="sd">        stage (str): The current stage of the step the level belongs to</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># get current level and problem description</span>
    <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span>

    <span class="c1"># Check if we want to skip the residual computation to gain performance</span>
    <span class="c1"># Keep in mind that skipping any residual computation is likely to give incorrect outputs of the residual!</span>
    <span class="k">if</span> <span class="n">stage</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">skip_residual_computation</span><span class="p">:</span>
        <span class="n">L</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">residual</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="k">if</span> <span class="n">L</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">residual</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">L</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">residual</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># check if there are new values (e.g. from a sweep)</span>
    <span class="c1"># assert L.status.updated</span>

    <span class="c1"># compute the residual for each node</span>

    <span class="c1"># build QF(u)</span>
    <span class="n">res_norm</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">integrate</span><span class="p">()</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">prob</span><span class="o">.</span><span class="n">diff_mask</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coll</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">):</span>
        <span class="n">res</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span> <span class="o">+=</span> <span class="n">L</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span> <span class="o">-</span> <span class="n">L</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span>
        <span class="c1"># add tau if associated</span>
        <span class="k">if</span> <span class="n">L</span><span class="o">.</span><span class="n">tau</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">res</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+=</span> <span class="n">L</span><span class="o">.</span><span class="n">tau</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
        <span class="c1"># use abs function from data type here</span>
        <span class="n">res_norm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">m</span><span class="p">]))</span>

    <span class="c1"># find maximal residual over the nodes</span>
    <span class="k">if</span> <span class="n">L</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">residual_type</span> <span class="o">==</span> <span class="s1">&#39;full_abs&#39;</span><span class="p">:</span>
        <span class="n">L</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">residual</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">res_norm</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">L</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">residual_type</span> <span class="o">==</span> <span class="s1">&#39;last_abs&#39;</span><span class="p">:</span>
        <span class="n">L</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">residual</span> <span class="o">=</span> <span class="n">res_norm</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">L</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">residual_type</span> <span class="o">==</span> <span class="s1">&#39;full_rel&#39;</span><span class="p">:</span>
        <span class="n">L</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">residual</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">res_norm</span><span class="p">)</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">L</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">residual_type</span> <span class="o">==</span> <span class="s1">&#39;last_rel&#39;</span><span class="p">:</span>
        <span class="n">L</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">residual</span> <span class="o">=</span> <span class="n">res_norm</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ParameterError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;residual_type = </span><span class="si">{</span><span class="n">L</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">residual_type</span><span class="si">}</span><span class="s1"> not implemented, choose &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;full_abs, last_abs, full_rel or last_rel instead&#39;</span>
        <span class="p">)</span>

    <span class="c1"># indicate that the residual has seen the new values</span>
    <span class="n">L</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">updated</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="compute_residual_DAE_MPI">
<a class="viewcode-back" href="../../../pySDC/implementations.problem_classes.generic_spectral.html#implementations.problem_classes.generic_spectral.compute_residual_DAE_MPI">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_residual_DAE_MPI</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stage</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computation of the residual using the collocation matrix Q</span>

<span class="sd">    Args:</span>
<span class="sd">        stage (str): The current stage of the step the level belongs to</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">mpi4py</span><span class="w"> </span><span class="kn">import</span> <span class="n">MPI</span>

    <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span>

    <span class="c1"># Check if we want to skip the residual computation to gain performance</span>
    <span class="c1"># Keep in mind that skipping any residual computation is likely to give incorrect outputs of the residual!</span>
    <span class="k">if</span> <span class="n">stage</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">skip_residual_computation</span><span class="p">:</span>
        <span class="n">L</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">residual</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="k">if</span> <span class="n">L</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">residual</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">L</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">residual</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># compute the residual for each node</span>

    <span class="c1"># build QF(u)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">last_only</span><span class="o">=</span><span class="n">L</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">residual_type</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;last&#39;</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">prob</span><span class="o">.</span><span class="n">diff_mask</span>
    <span class="n">res</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">+=</span> <span class="n">L</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span> <span class="o">-</span> <span class="n">L</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span>
    <span class="c1"># add tau if associated</span>
    <span class="k">if</span> <span class="n">L</span><span class="o">.</span><span class="n">tau</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">+=</span> <span class="n">L</span><span class="o">.</span><span class="n">tau</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">]</span>
    <span class="c1"># use abs function from data type here</span>
    <span class="n">res_norm</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

    <span class="c1"># find maximal residual over the nodes</span>
    <span class="k">if</span> <span class="n">L</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">residual_type</span> <span class="o">==</span> <span class="s1">&#39;full_abs&#39;</span><span class="p">:</span>
        <span class="n">L</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">residual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="n">res_norm</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">MPI</span><span class="o">.</span><span class="n">MAX</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">L</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">residual_type</span> <span class="o">==</span> <span class="s1">&#39;last_abs&#39;</span><span class="p">:</span>
        <span class="n">L</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">residual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">res_norm</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">L</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">residual_type</span> <span class="o">==</span> <span class="s1">&#39;full_rel&#39;</span><span class="p">:</span>
        <span class="n">L</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">residual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="n">res_norm</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">op</span><span class="o">=</span><span class="n">MPI</span><span class="o">.</span><span class="n">MAX</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">L</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">residual_type</span> <span class="o">==</span> <span class="s1">&#39;last_rel&#39;</span><span class="p">:</span>
        <span class="n">L</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">residual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">res_norm</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">root</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;residual type </span><span class="se">\&quot;</span><span class="si">{</span><span class="n">L</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">residual_type</span><span class="si">}</span><span class="se">\&quot;</span><span class="s1"> not implemented!&#39;</span><span class="p">)</span>

    <span class="c1"># indicate that the residual has seen the new values</span>
    <span class="n">L</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">updated</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="get_extrapolated_error_DAE">
<a class="viewcode-back" href="../../../pySDC/implementations.problem_classes.generic_spectral.html#implementations.problem_classes.generic_spectral.get_extrapolated_error_DAE">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_extrapolated_error_DAE</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The extrapolation estimate combines values of u and f from multiple steps to extrapolate and compare to the</span>
<span class="sd">    solution obtained by the time marching scheme. This function can be used in `EstimateExtrapolationError`.</span>

<span class="sd">    Args:</span>
<span class="sd">        S (pySDC.Step): The current step</span>

<span class="sd">    Returns:</span>
<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u_ex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_extrapolated_solution</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="n">diff_mask</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">prob</span><span class="o">.</span><span class="n">diff_mask</span>
    <span class="k">if</span> <span class="n">u_ex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">S</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">error_extrapolation_estimate</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">abs</span><span class="p">((</span><span class="n">u_ex</span> <span class="o">-</span> <span class="n">S</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="n">diff_mask</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="o">.</span><span class="n">prefactor</span>
        <span class="p">)</span>
        <span class="c1"># print([abs(me) for me in (u_ex - S.levels[0].u[-1]) * self.coeff.prefactor])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">S</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">error_extrapolation_estimate</span> <span class="o">=</span> <span class="kc">None</span></div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">pySDC 5.6 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">implementations.problem_classes.generic_spectral</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2024, Robert Speck.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3.
    </div>
  </body>
</html>