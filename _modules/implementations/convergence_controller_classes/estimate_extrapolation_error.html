<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>implementations.convergence_controller_classes.estimate_extrapolation_error &#8212; pySDC 5.5.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/classic.css?v=def86cc0" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom.css?v=c40552b6" />
    
    <script src="../../../_static/documentation_options.js?v=a385a3de"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">pySDC 5.5.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">implementations.convergence_controller_classes.estimate_extrapolation_error</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for implementations.convergence_controller_classes.estimate_extrapolation_error</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">factorial</span>

<span class="kn">from</span> <span class="nn">pySDC.core.convergence_controller</span> <span class="kn">import</span> <span class="n">ConvergenceController</span><span class="p">,</span> <span class="n">Status</span>
<span class="kn">from</span> <span class="nn">pySDC.core.errors</span> <span class="kn">import</span> <span class="n">DataError</span>
<span class="kn">from</span> <span class="nn">pySDC.implementations.datatype_classes.mesh</span> <span class="kn">import</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">imex_mesh</span>
<span class="kn">from</span> <span class="nn">pySDC.implementations.hooks.log_extrapolated_error_estimate</span> <span class="kn">import</span> <span class="n">LogExtrapolationErrorEstimate</span>


<div class="viewcode-block" id="EstimateExtrapolationErrorBase">
<a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.estimate_extrapolation_error.html#implementations.convergence_controller_classes.estimate_extrapolation_error.EstimateExtrapolationErrorBase">[docs]</a>
<span class="k">class</span> <span class="nc">EstimateExtrapolationErrorBase</span><span class="p">(</span><span class="n">ConvergenceController</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract base class for extrapolated error estimates</span>
<span class="sd">    ----------------------------------------------------</span>
<span class="sd">    This error estimate extrapolates a solution based on Taylor expansions using solutions of previous time steps.</span>
<span class="sd">    In particular, child classes need to implement how to make these solutions available, which works differently for</span>
<span class="sd">    MPI and non-MPI versions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">controller</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialization routine</span>

<span class="sd">        Args:</span>
<span class="sd">            controller (pySDC.Controller): The controller</span>
<span class="sd">            params (dict): The params passed for this specific convergence controller</span>
<span class="sd">            description (dict): The description object used to instantiate the controller</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">Status</span><span class="p">([</span><span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="s2">&quot;u&quot;</span><span class="p">,</span> <span class="s2">&quot;f&quot;</span><span class="p">,</span> <span class="s2">&quot;dt&quot;</span><span class="p">])</span>  <span class="c1"># store solutions etc. of previous steps here</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">Status</span><span class="p">([</span><span class="s2">&quot;u&quot;</span><span class="p">,</span> <span class="s2">&quot;f&quot;</span><span class="p">,</span> <span class="s2">&quot;prefactor&quot;</span><span class="p">])</span>  <span class="c1"># store coefficients for extrapolation here</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">controller</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">description</span><span class="p">)</span>
        <span class="n">controller</span><span class="o">.</span><span class="n">add_hook</span><span class="p">(</span><span class="n">LogExtrapolationErrorEstimate</span><span class="p">)</span>

<div class="viewcode-block" id="EstimateExtrapolationErrorBase.setup">
<a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.estimate_extrapolation_error.html#implementations.convergence_controller_classes.estimate_extrapolation_error.EstimateExtrapolationErrorBase.setup">[docs]</a>
    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">controller</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The extrapolation based method requires storage of previous values of u, f, t and dt and also requires solving</span>
<span class="sd">        a linear system of equations to compute the Taylor expansion finite difference style. Here, all variables are</span>
<span class="sd">        initialized which are needed for this process.</span>

<span class="sd">        Args:</span>
<span class="sd">            controller (pySDC.Controller): The controller</span>
<span class="sd">            params (dict): The params passed for this specific convergence controller</span>
<span class="sd">            description (dict): The description object used to instantiate the controller</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: Updated parameters with default values</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">pySDC.implementations.convergence_controller_classes.hotrod</span> <span class="kn">import</span> <span class="n">HotRod</span>
        <span class="kn">from</span> <span class="nn">pySDC.implementations.convergence_controller_classes.adaptivity</span> <span class="kn">import</span> <span class="p">(</span>
            <span class="n">Adaptivity</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">default_params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;control_order&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">75</span><span class="p">,</span>
            <span class="s2">&quot;use_adaptivity&quot;</span><span class="p">:</span> <span class="kc">True</span> <span class="ow">in</span> <span class="p">[</span><span class="n">me</span> <span class="o">==</span> <span class="n">Adaptivity</span> <span class="k">for</span> <span class="n">me</span> <span class="ow">in</span> <span class="n">description</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;convergence_controllers&quot;</span><span class="p">,</span> <span class="p">{})],</span>
            <span class="s2">&quot;use_HotRod&quot;</span><span class="p">:</span> <span class="kc">True</span> <span class="ow">in</span> <span class="p">[</span><span class="n">me</span> <span class="o">==</span> <span class="n">HotRod</span> <span class="k">for</span> <span class="n">me</span> <span class="ow">in</span> <span class="n">description</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;convergence_controllers&quot;</span><span class="p">,</span> <span class="p">{})],</span>
            <span class="s2">&quot;order_time_marching&quot;</span><span class="p">:</span> <span class="n">description</span><span class="p">[</span><span class="s2">&quot;step_params&quot;</span><span class="p">][</span><span class="s2">&quot;maxiter&quot;</span><span class="p">],</span>
        <span class="p">}</span>

        <span class="n">new_params</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">default_params</span><span class="p">,</span> <span class="o">**</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="n">controller</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)}</span>

        <span class="c1"># Do a sufficiently high order Taylor expansion</span>
        <span class="n">new_params</span><span class="p">[</span><span class="s2">&quot;Taylor_order&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_params</span><span class="p">[</span><span class="s2">&quot;order_time_marching&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span>

        <span class="c1"># Estimate and store values from this iteration</span>
        <span class="n">new_params</span><span class="p">[</span><span class="s2">&quot;estimate_iter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_params</span><span class="p">[</span><span class="s2">&quot;order_time_marching&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">new_params</span><span class="p">[</span><span class="s2">&quot;use_HotRod&quot;</span><span class="p">]</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Store n values. Since we store u and f, we need only half of each (the +1 is for rounding)</span>
        <span class="n">new_params</span><span class="p">[</span><span class="s2">&quot;n&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_params</span><span class="p">[</span><span class="s2">&quot;Taylor_order&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">new_params</span><span class="p">[</span><span class="s2">&quot;n_per_proc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_params</span><span class="p">[</span><span class="s2">&quot;n&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">new_params</span></div>


<div class="viewcode-block" id="EstimateExtrapolationErrorBase.setup_status_variables">
<a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.estimate_extrapolation_error.html#implementations.convergence_controller_classes.estimate_extrapolation_error.EstimateExtrapolationErrorBase.setup_status_variables">[docs]</a>
    <span class="k">def</span> <span class="nf">setup_status_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">controller</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize coefficient variables and add variable to the levels for extrapolated error</span>

<span class="sd">        Args:</span>
<span class="sd">            controller (pySDC.controller): The controller</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">n</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_status_variable_to_level</span><span class="p">(</span><span class="s1">&#39;error_extrapolation_estimate&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="EstimateExtrapolationErrorBase.check_parameters">
<a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.estimate_extrapolation_error.html#implementations.convergence_controller_classes.estimate_extrapolation_error.EstimateExtrapolationErrorBase.check_parameters">[docs]</a>
    <span class="k">def</span> <span class="nf">check_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">controller</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether parameters are compatible with whatever assumptions went into the step size functions etc.</span>

<span class="sd">        Args:</span>
<span class="sd">            controller (pySDC.Controller): The controller</span>
<span class="sd">            params (dict): The params passed for this specific convergence controller</span>
<span class="sd">            description (dict): The description object used to instantiate the controller</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: Whether the parameters are compatible</span>
<span class="sd">            str: Error message</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">description</span><span class="p">[</span><span class="s2">&quot;step_params&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;restol&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="kc">False</span><span class="p">,</span>
                <span class="s2">&quot;Extrapolation error needs constant order in time and hence restol in the step parameters </span><span class="se">\</span>
<span class="s2">has to be smaller than 0!&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">controller</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">mssdc_jac</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="kc">False</span><span class="p">,</span>
                <span class="s2">&quot;Extrapolation error estimator needs the same order on all steps, please activate Gauss-Seid</span><span class="se">\</span>
<span class="s2">el multistep mode!&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;&quot;</span></div>


<div class="viewcode-block" id="EstimateExtrapolationErrorBase.store_values">
<a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.estimate_extrapolation_error.html#implementations.convergence_controller_classes.estimate_extrapolation_error.EstimateExtrapolationErrorBase.store_values">[docs]</a>
    <span class="k">def</span> <span class="nf">store_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Store the required attributes of the step to do the extrapolation. We only care about the last collocation</span>
<span class="sd">        node on the finest level at the moment.</span>

<span class="sd">        Args:</span>
<span class="sd">            S (pySDC.Step): The current step</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># figure out which values are to be replaced by the new ones</span>
        <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">prev</span><span class="o">.</span><span class="n">t</span><span class="p">:</span>
            <span class="n">oldest_val</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prev</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prev</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">prev</span><span class="o">.</span><span class="n">t</span> <span class="o">==</span> <span class="p">[</span><span class="kc">None</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">oldest_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prev</span><span class="o">.</span><span class="n">t</span><span class="p">)</span>

        <span class="c1"># figure out how to store the right hand side</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">==</span> <span class="n">imex_mesh</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prev</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">oldest_val</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">impl</span> <span class="o">+</span> <span class="n">f</span><span class="o">.</span><span class="n">expl</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">==</span> <span class="n">mesh</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prev</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">oldest_val</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unable to store f from datatype </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="si">}</span><span class="s2">, extrapolation based error estimate only</span><span class="se">\</span>
<span class="s2"> works with types imex_mesh and mesh&quot;</span>
            <span class="p">)</span>

        <span class="c1"># store the rest of the values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prev</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">oldest_val</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prev</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="n">oldest_val</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">time</span> <span class="o">+</span> <span class="n">S</span><span class="o">.</span><span class="n">dt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prev</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="n">oldest_val</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">dt</span>

        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="EstimateExtrapolationErrorBase.get_extrapolation_coefficients">
<a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.estimate_extrapolation_error.html#implementations.convergence_controller_classes.estimate_extrapolation_error.EstimateExtrapolationErrorBase.get_extrapolation_coefficients">[docs]</a>
    <span class="k">def</span> <span class="nf">get_extrapolation_coefficients</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">t_eval</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function solves a linear system where in the matrix A, the row index reflects the order of the derivative</span>
<span class="sd">        in the Taylor expansion and the column index reflects the particular step and whether its u or f from that</span>
<span class="sd">        step. The vector b on the other hand, contains a 1 in the first entry and zeros elsewhere, since we want to</span>
<span class="sd">        compute the value itself and all the derivatives should vanish after combining the Taylor expansions. This</span>
<span class="sd">        works to the order of the number of rows and since we want a square matrix for solving, we need the same amount</span>
<span class="sd">        of columns, which determines the memory overhead, since it is equal to the solutions / rhs that we need in</span>
<span class="sd">        memory at the time of evaluation.</span>

<span class="sd">        This is enough to get the extrapolated solution, but if we want to compute the local error, we have to compute</span>
<span class="sd">        a prefactor. This is based on error accumulation between steps (first step&#39;s solution is exact plus 1 LTE,</span>
<span class="sd">        second solution is exact plus 2 LTE and so on), which can be computed for adaptive step sizes as well. However,</span>
<span class="sd">        this is only true for linear problems, which means we expect the error estimate to work less well for non-linear</span>
<span class="sd">        problems.</span>

<span class="sd">        Since only time differences are important for computing the coefficients, we need to compute this only once when</span>
<span class="sd">        using constant step sizes. When we allow the step size to change, however, we need to recompute this in every</span>
<span class="sd">        step, which is activated by the `use_adaptivity` parameter.</span>

<span class="sd">        Solving for the coefficients requires solving a dense linear system of equations. The number of unknowns is</span>
<span class="sd">        equal to the order of the Taylor expansion, so this step should be cheap compared to the solves in each SDC</span>
<span class="sd">        iteration.</span>

<span class="sd">        The function stores the computed coefficients in the `self.coeff` variables.</span>

<span class="sd">        Args:</span>
<span class="sd">            t (list): The list of times at which we have solutions available</span>
<span class="sd">            dt (list): The step sizes used for computing these solutions (needed for the prefactor)</span>
<span class="sd">            t_eval (float): The time we want to extrapolate to</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># prepare A matrix</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">Taylor_order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">Taylor_order</span><span class="p">))</span>
        <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">Taylor_order</span><span class="p">)</span>
        <span class="n">inv_facs</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">factorial</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

        <span class="c1"># get the steps backwards from the point of evaluation</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">steps_from_now</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">t_eval</span>

        <span class="c1"># fill A matrix</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">Taylor_order</span><span class="p">):</span>
            <span class="c1"># Taylor expansions of the solutions</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">steps_from_now</span> <span class="o">**</span> <span class="n">j</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">inv_facs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># Taylor expansions of the first derivatives a.k.a. right hand side evaluations</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">n</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">Taylor_order</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">steps_from_now</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">Taylor_order</span> <span class="p">:]</span> <span class="o">**</span> <span class="p">(</span><span class="n">j</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">inv_facs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="c1"># prepare rhs</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">Taylor_order</span><span class="p">)</span>
        <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="c1"># solve linear system for the coefficients</span>
        <span class="n">coeff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">coeff</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">n</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">n</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">Taylor_order</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">coeff</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">n</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">Taylor_order</span><span class="p">]</span>

        <span class="c1"># determine prefactor</span>
        <span class="n">step_size_ratios</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dt</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="o">.</span><span class="n">u</span><span class="p">)</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">dt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">Taylor_order</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">inv_prefactor</span> <span class="o">=</span> <span class="o">-</span><span class="nb">sum</span><span class="p">(</span><span class="n">step_size_ratios</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">-</span> <span class="mf">1.0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="o">.</span><span class="n">u</span><span class="p">)):</span>
            <span class="n">inv_prefactor</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">step_size_ratios</span><span class="p">[</span><span class="mi">1</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="o">.</span><span class="n">prefactor</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">inv_prefactor</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span></div>
</div>



<div class="viewcode-block" id="EstimateExtrapolationErrorNonMPI">
<a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.estimate_extrapolation_error.html#implementations.convergence_controller_classes.estimate_extrapolation_error.EstimateExtrapolationErrorNonMPI">[docs]</a>
<span class="k">class</span> <span class="nc">EstimateExtrapolationErrorNonMPI</span><span class="p">(</span><span class="n">EstimateExtrapolationErrorBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implementation of the extrapolation error estimate for the non-MPI controller.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="EstimateExtrapolationErrorNonMPI.setup">
<a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.estimate_extrapolation_error.html#implementations.convergence_controller_classes.estimate_extrapolation_error.EstimateExtrapolationErrorNonMPI.setup">[docs]</a>
    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">controller</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a no parameter &#39;no_storage&#39; which decides whether the standard or the no-memory-overhead version is run,</span>
<span class="sd">        where only values are used for extrapolation which are in memory of other processes</span>

<span class="sd">        Args:</span>
<span class="sd">            controller (pySDC.Controller): The controller</span>
<span class="sd">            params (dict): The params passed for this specific convergence controller</span>
<span class="sd">            description (dict): The description object used to instantiate the controller</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: Updated parameters with default values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">default_params</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="n">controller</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">description</span><span class="p">)</span>

        <span class="n">non_mpi_defaults</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;no_storage&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="p">{</span><span class="o">**</span><span class="n">non_mpi_defaults</span><span class="p">,</span> <span class="o">**</span><span class="n">default_params</span><span class="p">}</span></div>


<div class="viewcode-block" id="EstimateExtrapolationErrorNonMPI.setup_status_variables">
<a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.estimate_extrapolation_error.html#implementations.convergence_controller_classes.estimate_extrapolation_error.EstimateExtrapolationErrorNonMPI.setup_status_variables">[docs]</a>
    <span class="k">def</span> <span class="nf">setup_status_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">controller</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize storage variables.</span>

<span class="sd">        Args:</span>
<span class="sd">            controller (pySDC.controller): The controller</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">setup_status_variables</span><span class="p">(</span><span class="n">controller</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">prev</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prev</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prev</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prev</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">n</span>

        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="EstimateExtrapolationErrorNonMPI.post_iteration_processing">
<a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.estimate_extrapolation_error.html#implementations.convergence_controller_classes.estimate_extrapolation_error.EstimateExtrapolationErrorNonMPI.post_iteration_processing">[docs]</a>
    <span class="k">def</span> <span class="nf">post_iteration_processing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">controller</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        We perform three key operations here in the last iteration:</span>
<span class="sd">         - Compute the error estimate</span>
<span class="sd">         - Compute the coefficients if needed</span>
<span class="sd">         - Store the values of the step if we pretend not to for the no-memory overhead version</span>

<span class="sd">        Args:</span>
<span class="sd">            controller (pySDC.Controller): The controller</span>
<span class="sd">            S (pySDC.Step): The current step</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">S</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">iter</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">estimate_iter</span><span class="p">:</span>
            <span class="n">t_eval</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">time</span> <span class="o">+</span> <span class="n">S</span><span class="o">.</span><span class="n">dt</span>

            <span class="c1"># compute the extrapolation coefficients if needed</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="p">(</span>
                    <span class="kc">None</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="o">.</span><span class="n">u</span>
                    <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">use_adaptivity</span>
                    <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">no_storage</span> <span class="ow">and</span> <span class="n">S</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">time_size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="ow">and</span> <span class="kc">None</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">prev</span><span class="o">.</span><span class="n">t</span>
                <span class="ow">and</span> <span class="n">t_eval</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prev</span><span class="o">.</span><span class="n">t</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_extrapolation_coefficients</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prev</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prev</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">t_eval</span><span class="p">)</span>

            <span class="c1"># compute the error if we can</span>
            <span class="k">if</span> <span class="kc">None</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="o">.</span><span class="n">u</span> <span class="ow">and</span> <span class="kc">None</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">prev</span><span class="o">.</span><span class="n">t</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_extrapolated_error</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

            <span class="c1"># store the solution and pretend we didn&#39;t because in the non MPI version we take a few shortcuts</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">no_storage</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">store_values</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="EstimateExtrapolationErrorNonMPI.prepare_next_block">
<a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.estimate_extrapolation_error.html#implementations.convergence_controller_classes.estimate_extrapolation_error.EstimateExtrapolationErrorNonMPI.prepare_next_block">[docs]</a>
    <span class="k">def</span> <span class="nf">prepare_next_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">controller</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">Tend</span><span class="p">,</span> <span class="n">MS</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If the no-memory-overhead version is used, we need to delete stuff that shouldn&#39;t be available. Otherwise, we</span>
<span class="sd">        need to store all the stuff that we can.</span>

<span class="sd">        Args:</span>
<span class="sd">            controller (pySDC.Controller): The controller</span>
<span class="sd">            S (pySDC.step): The current step</span>
<span class="sd">            size (int): Number of ranks</span>
<span class="sd">            time (float): The current time</span>
<span class="sd">            Tend (float): The final time</span>
<span class="sd">            MS (list): Active steps</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># delete values that should not be available in the next step</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">no_storage</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prev</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prev</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prev</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">n</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prev</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">n</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># decide where we need to restart to store everything up to that point</span>
            <span class="n">restarts</span> <span class="o">=</span> <span class="p">[</span><span class="n">S</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">restart</span> <span class="k">for</span> <span class="n">S</span> <span class="ow">in</span> <span class="n">MS</span><span class="p">]</span>
            <span class="n">restart_at</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">restarts</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="kc">True</span> <span class="ow">in</span> <span class="n">restarts</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">MS</span><span class="p">)</span>

            <span class="c1"># store values in the current block that don&#39;t need restarting</span>
            <span class="k">if</span> <span class="n">restart_at</span> <span class="o">&gt;</span> <span class="n">S</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">slot</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">store_values</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="EstimateExtrapolationErrorNonMPI.get_extrapolated_solution">
<a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.estimate_extrapolation_error.html#implementations.convergence_controller_classes.estimate_extrapolation_error.EstimateExtrapolationErrorNonMPI.get_extrapolated_solution">[docs]</a>
    <span class="k">def</span> <span class="nf">get_extrapolated_solution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Combine values from previous steps to extrapolate.</span>

<span class="sd">        Args:</span>
<span class="sd">            S (pySDC.Step): The current step</span>

<span class="sd">        Returns:</span>
<span class="sd">            dtype_u: The extrapolated solution</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Extrapolated estimate only works on the finest level for now&quot;</span><span class="p">)</span>

        <span class="c1"># prepare variables</span>
        <span class="n">u_ex</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.0</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prev</span><span class="o">.</span><span class="n">t</span><span class="p">)</span>

        <span class="c1"># see if we have a solution for the current step already stored</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">time</span> <span class="o">+</span> <span class="n">S</span><span class="o">.</span><span class="n">dt</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">prev</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">10.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">idx_step</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prev</span><span class="o">.</span><span class="n">t</span> <span class="o">-</span> <span class="n">S</span><span class="o">.</span><span class="n">time</span> <span class="o">-</span> <span class="n">S</span><span class="o">.</span><span class="n">dt</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx_step</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># make a mask of all the steps we want to include in the extrapolation</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">idx_step</span><span class="p">,</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">idx_step</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>

        <span class="c1"># do the extrapolation by summing everything up</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="n">u_ex</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">prev</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">mask</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">prev</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">mask</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span>

        <span class="k">return</span> <span class="n">u_ex</span></div>


<div class="viewcode-block" id="EstimateExtrapolationErrorNonMPI.get_extrapolated_error">
<a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.estimate_extrapolation_error.html#implementations.convergence_controller_classes.estimate_extrapolation_error.EstimateExtrapolationErrorNonMPI.get_extrapolated_error">[docs]</a>
    <span class="k">def</span> <span class="nf">get_extrapolated_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The extrapolation estimate combines values of u and f from multiple steps to extrapolate and compare to the</span>
<span class="sd">        solution obtained by the time marching scheme.</span>

<span class="sd">        Args:</span>
<span class="sd">            S (pySDC.Step): The current step</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">u_ex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_extrapolated_solution</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">u_ex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">S</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">error_extrapolation_estimate</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u_ex</span> <span class="o">-</span> <span class="n">S</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="o">.</span><span class="n">prefactor</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">S</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">error_extrapolation_estimate</span> <span class="o">=</span> <span class="kc">None</span></div>
</div>



<div class="viewcode-block" id="EstimateExtrapolationErrorWithinQ">
<a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.estimate_extrapolation_error.html#implementations.convergence_controller_classes.estimate_extrapolation_error.EstimateExtrapolationErrorWithinQ">[docs]</a>
<span class="k">class</span> <span class="nc">EstimateExtrapolationErrorWithinQ</span><span class="p">(</span><span class="n">EstimateExtrapolationErrorBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This convergence controller estimates the local error based on comparing the SDC solution to an extrapolated</span>
<span class="sd">    solution within the quadrature matrix. Collocation methods compute a high order solution from a linear combination</span>
<span class="sd">    of solutions at intermediate time points. While the intermediate solutions (a.k.a. stages) don&#39;t share the order of</span>
<span class="sd">    accuracy with the solution at the end of the interval, for SDC we know that the order is equal to the number of</span>
<span class="sd">    nodes + 1 (locally). This is because the solution to the collocation problem is a polynomial approximation of order</span>
<span class="sd">    of the number of nodes.</span>
<span class="sd">    That means we can do a Taylor expansion around the end point of the interval to higher order and after cancelling</span>
<span class="sd">    terms just like we are used to with the extrapolation based error estimate across multiple steps, we get an error</span>
<span class="sd">    estimate that is of the order of accuracy of the stages.</span>
<span class="sd">    This can be used for adaptivity, for instance, with the nice property that it doesn&#39;t matter how we arrived at the</span>
<span class="sd">    converged collocation solution, as long as we did. We don&#39;t rely on knowing the order of accuracy after every sweep,</span>
<span class="sd">    only after convergence of the collocation problem has been achieved, which we can check from the residual.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="EstimateExtrapolationErrorWithinQ.setup">
<a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.estimate_extrapolation_error.html#implementations.convergence_controller_classes.estimate_extrapolation_error.EstimateExtrapolationErrorWithinQ.setup">[docs]</a>
    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">controller</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        We need this convergence controller to become active after the check for convergence, because we need the step</span>
<span class="sd">        to be converged.</span>

<span class="sd">        Args:</span>
<span class="sd">            controller (pySDC.Controller): The controller</span>
<span class="sd">            params (dict): The params passed for this specific convergence controller</span>
<span class="sd">            description (dict): The description object used to instantiate the controller</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: Updated parameters with default values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pySDC.implementations.convergence_controller_classes.check_convergence</span> <span class="kn">import</span> <span class="n">CheckConvergence</span>

        <span class="n">num_nodes</span> <span class="o">=</span> <span class="n">description</span><span class="p">[</span><span class="s1">&#39;sweeper_params&#39;</span><span class="p">][</span><span class="s1">&#39;num_nodes&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span> <span class="o">=</span> <span class="n">description</span><span class="p">[</span><span class="s1">&#39;sweeper_params&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;comm&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">mpi4py</span> <span class="kn">import</span> <span class="n">MPI</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">sum</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">SUM</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">check_convergence</span> <span class="o">=</span> <span class="n">CheckConvergence</span><span class="o">.</span><span class="n">check_convergence</span>

        <span class="n">default_params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;Taylor_order&#39;</span><span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">num_nodes</span><span class="p">,</span>
            <span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="n">num_nodes</span><span class="p">,</span>
            <span class="s1">&#39;recompute_coefficients&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="o">**</span><span class="n">params</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="p">{</span><span class="o">**</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="n">controller</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="o">**</span><span class="n">default_params</span><span class="p">}</span></div>


<div class="viewcode-block" id="EstimateExtrapolationErrorWithinQ.post_iteration_processing">
<a class="viewcode-back" href="../../../pySDC/implementations.convergence_controller_classes.estimate_extrapolation_error.html#implementations.convergence_controller_classes.estimate_extrapolation_error.EstimateExtrapolationErrorWithinQ.post_iteration_processing">[docs]</a>
    <span class="k">def</span> <span class="nf">post_iteration_processing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">controller</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the extrapolated error estimate here if the step is converged.</span>

<span class="sd">        Args:</span>
<span class="sd">            controller (pySDC.Controller): The controller</span>
<span class="sd">            S (pySDC.Step): The current step</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_convergence</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">lvl</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">nodes_</span> <span class="o">=</span> <span class="n">lvl</span><span class="o">.</span><span class="n">sweep</span><span class="o">.</span><span class="n">coll</span><span class="o">.</span><span class="n">nodes</span> <span class="o">*</span> <span class="n">S</span><span class="o">.</span><span class="n">dt</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">time</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nodes_</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">t_eval</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">time</span> <span class="o">+</span> <span class="n">nodes_</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">dts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nodes_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nodes_</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">nodes_</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">Taylor_order</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>

        <span class="c1"># compute the extrapolation coefficients</span>
        <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="o">.</span><span class="n">u</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">recompute_coefficients</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_extrapolation_coefficients</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">dts</span><span class="p">,</span> <span class="n">t_eval</span><span class="p">)</span>

        <span class="c1"># compute the extrapolated solution</span>
        <span class="k">if</span> <span class="n">lvl</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lvl</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">lvl</span><span class="o">.</span><span class="n">prob</span><span class="o">.</span><span class="n">eval_f</span><span class="p">(</span><span class="n">lvl</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lvl</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">lvl</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">imex_mesh</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">lvl</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">impl</span> <span class="o">+</span> <span class="n">lvl</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">expl</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">lvl</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">else</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lvl</span><span class="o">.</span><span class="n">f</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">lvl</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">mesh</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">lvl</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">else</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lvl</span><span class="o">.</span><span class="n">f</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DataError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unable to store f from datatype </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">lvl</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s2">, extrapolation based error estimate only</span><span class="se">\</span>
<span class="s2"> works with types imex_mesh and mesh&quot;</span>
            <span class="p">)</span>

        <span class="c1"># compute the error with the weighted sum</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span>
            <span class="n">sendbuf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">lvl</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">u_ex</span> <span class="o">=</span> <span class="n">lvl</span><span class="o">.</span><span class="n">prob</span><span class="o">.</span><span class="n">dtype_u</span><span class="p">(</span><span class="n">lvl</span><span class="o">.</span><span class="n">prob</span><span class="o">.</span><span class="n">init</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Reduce</span><span class="p">(</span><span class="n">sendbuf</span><span class="p">,</span> <span class="n">u_ex</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">u_ex</span> <span class="o">=</span> <span class="n">lvl</span><span class="o">.</span><span class="n">prob</span><span class="o">.</span><span class="n">dtype_u</span><span class="p">(</span><span class="n">lvl</span><span class="o">.</span><span class="n">prob</span><span class="o">.</span><span class="n">init</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                <span class="n">u_ex</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">lvl</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># store the error</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">:</span>
            <span class="n">error</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">abs</span><span class="p">(</span><span class="n">u_ex</span> <span class="o">-</span> <span class="n">lvl</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="o">.</span><span class="n">prefactor</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">else</span> <span class="kc">None</span>
            <span class="p">)</span>
            <span class="n">lvl</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">error_extrapolation_estimate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lvl</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">error_extrapolation_estimate</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u_ex</span> <span class="o">-</span> <span class="n">lvl</span><span class="o">.</span><span class="n">u</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="o">.</span><span class="n">prefactor</span>
        <span class="k">return</span> <span class="kc">None</span></div>
</div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">pySDC 5.5.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">implementations.convergence_controller_classes.estimate_extrapolation_error</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2024, Robert Speck.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.0.2.
    </div>
  </body>
</html>