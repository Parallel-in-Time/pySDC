<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Solving differential algebraic equations with SDC &#8212; pySDC 5.5.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=def86cc0" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=c40552b6" />
    
    <script src="../_static/documentation_options.js?v=a385a3de"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Compression in pySDC" href="compression.html" />
    <link rel="prev" title="Resilience in SDC" href="Resilience.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="compression.html" title="Compression in pySDC"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="Resilience.html" title="Resilience in SDC"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">pySDC 5.5.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Solving differential algebraic equations with SDC</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="solving-differential-algebraic-equations-with-sdc">
<h1>Solving differential algebraic equations with SDC<a class="headerlink" href="#solving-differential-algebraic-equations-with-sdc" title="Link to this heading">¶</a></h1>
<p>This project contains the sweepers, hooks, example problems, plotting and simulation scripts for a Master’s thesis investigating the usage of SDC methods to solve differential algebraic equations (DAEs).</p>
<p>To run the scripts contained in this project a standard installation of pySDC should suffice.</p>
<section id="project-overview">
<h2>Project overview<a class="headerlink" href="#project-overview" title="Link to this heading">¶</a></h2>
<ul>
<li><dl>
<dt>misc</dt><dd><ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">meshDAE.py</span></code></div>
<div class="line">Datatype for semi-explicit DAE problem classes differential and algebraic parts to have a clean treatment.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">hooksDAE.py</span></code></div>
<div class="line">Simple hook classes to read out the approximate solution and error after each time step.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">problemDAE.py</span></code></div>
<div class="line">Parent class for DAE problems containing the method to solve the (non)-linear system at each node/stage.</div>
</div>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl>
<dt>plotting</dt><dd><ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">linear_plot.py</span></code></div>
<div class="line">Reads a previously generated data file in <cite>.npy</cite> format and generates a plot on linear axis of the specified parameters.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">loglog_plot.py</span></code></div>
<div class="line">Reads a previously generated data file in <cite>.npy</cite> format and generates a plot on logarithmic axis of the specified parameters. Commonly used to generate convergence plots.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">semilogy_plot.py</span></code></div>
<div class="line">Reads a previously generated data file in <cite>.npy</cite> format and generates a plot on logarithmic y-axis and linear x-axis.</div>
</div>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl>
<dt>problems</dt><dd><ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">discontinousTestDAE.py</span></code></div>
<div class="line">Simple nonlinear semi-explicit index-1 DAE with discrete state event whose event time is known.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">pendulum2D.py</span></code></div>
<div class="line">Example of the pendulum described by a semi-implicit DAE of index 3.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">problematicF.py</span></code></div>
<div class="line">Fully-implicit DAE of index 2 which is not solvable for numerically solvable for certain choices of parameter <span class="math notranslate nohighlight">\(\eta\)</span>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">simpleDAE.py</span></code></div>
<div class="line">Linear semi-explicit index-2 system of Hessenberg form with known analytical solution.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">synchronousMachine.py</span></code></div>
<div class="line">Synchronous machine model attached to an infinite bus undergoing torque disturbance test. Results in an index-1 system.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">transistorAmplifier.py</span></code></div>
<div class="line">A two transistor amplifier model that results in an index-1 differential algebraic system. A nice example of a system resulting from a common real world situation.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">wscc9BusSystem.py</span></code></div>
<div class="line">Large power system test case with three reduced model synchronous machines and nine buses. It is also part of the <a class="reference external" href="https://github.com/Parallel-in-Time/pySDC/tree/master/pySDC/projects/PinTSimE">PinTSimE project</a>.</div>
</div>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl>
<dt>run</dt><dd><ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">run_convergence_test.py</span></code></div>
<div class="line">Script to generate convergence data of applying SDC to the simple linear index-2 differential algebraic system mentioned above.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">run_iteration_test.py</span></code></div>
<div class="line">Script to generate data describing behaviour of error and residual of applying SDC to the simple linear index-2 differential algebraic system mentioned above.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">fully_implicit_dae_playground.py</span></code></div>
<div class="line">Testing arena for the fully implicit sweeper.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">synchronous_machine_playground.py</span></code></div>
<div class="line">Testing arena for the synchronous machine model.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">accuracy_check_MPI.py</span></code></div>
<div class="line">Script checking the order of accuracy of MPI sweepers for DAEs of different indices.</div>
</div>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl>
<dt>sweepers</dt><dd><ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">fullyImplicitDAE.py</span></code></div>
<div class="line">Sweeper that accepts a fully implicit formulation of a system of differential equations and applies to it a modified version of spectral deferred correction</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">semiImplicitDAE.py</span></code></div>
<div class="line">SDC sweeper especially for semi-explicit DAEs. This sweeper is based on ideas mentioned in <a class="reference external" href="https://www.sciencedirect.com/science/article/abs/pii/S0021999106003147">Huang et al. (2007)</a>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">fullyImplicitDAEMPI.py</span></code></div>
<div class="line">MPI version of fully-implicit SDC-DAE sweeper.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">semiImplicitDAEMPI.py</span></code></div>
<div class="line">MPI version of semi-implicit SDC-DAE sweeper.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">rungeKuttaDAE.py</span></code></div>
<div class="line">Runge-Kutta methods that can be used to solve DAEs in pySDC in a fully-implicit description.</div>
</div>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>tests</dt><dd><p>Here, all tests for the project can be found.</p>
</dd>
</dl>
</li>
</ul>
</section>
<section id="theoretical-details">
<h2>Theoretical details<a class="headerlink" href="#theoretical-details" title="Link to this heading">¶</a></h2>
<p>A fully implicit representation of a system of differential equations takes the form</p>
<div class="math notranslate nohighlight">
\[\begin{eqnarray}
   F(u(t), u'(t), t) = 0.
\end{eqnarray}\]</div>
<p>A special case of such an implicit differential equation arises when the Jacobian <span class="math notranslate nohighlight">\(\partial_{u'}F\)</span> is singular. This implies that the derivative of some of the components of <span class="math notranslate nohighlight">\(u(t)\)</span> do not appear in the system of equations. The system is thus denoted a differential algebraic system of equations.</p>
<p>Since the derivative <span class="math notranslate nohighlight">\(u'(t)\)</span> cannot be isolated the Picard formulation used in SDC for ordinary differential equations (ODEs) cannot be used here. Instead the derivative, henceforth denoted by <span class="math notranslate nohighlight">\(U(t)\)</span>, is cast as the new unknown solution and the implicit system of equations is written as</p>
<div class="math notranslate nohighlight">
\[\begin{eqnarray}
   F\left(u_0+\int_0^tU(\tau)d\tau, U(t), t\right) = 0.
\end{eqnarray}\]</div>
<p>The solution <span class="math notranslate nohighlight">\(u(t)\)</span> can then be recovered using an quadrature step. This approach is also called the <em>yp-formulation</em>.</p>
<p>Based on this equation and an initial approximate solution <span class="math notranslate nohighlight">\(\tilde{U}\)</span>, the following error equation is formed</p>
<div class="math notranslate nohighlight">
\[\begin{eqnarray}
   F\left(u_0+\int_0^t(\tilde{U}(t)+\delta(\tau))d\tau,\;\tilde{U}(t)+\delta(t)\;\right)=0.
\end{eqnarray}\]</div>
<p>This results directly in</p>
<div class="math notranslate nohighlight">
\[\begin{eqnarray}
   F\left(u_0+\int_0^{t_{m+1}}\tilde{U}(\tau)d\tau +\left(\int_0^{t_m} + \int_{t_m}^{t_{m+1}}\right)\delta(\tau)d\tau ,\;\tilde{U}(t_{m+1})+\delta(t_{m+1}),\;t_{m+1}\right)=0
\end{eqnarray}\]</div>
<p>from which the following time marching discretisation becomes obvious</p>
<div class="math notranslate nohighlight">
\[\begin{eqnarray}
   F\left(u_0+[\Delta t\mathbf{Q}\tilde{U}]_{m+1} + \sum_{l=1}^{m+1}\Delta t\tilde{\delta}_l,\;\tilde{U}_{m+1}+\tilde{\delta}_{m+1},\;t_{m+1}\right) = 0.
\end{eqnarray}\]</div>
<p>The spectral integration matrix <span class="math notranslate nohighlight">\(\mathbf{Q}\)</span> is used to approximate the integral of the current approximation <span class="math notranslate nohighlight">\(\tilde{U}\)</span> and a low order approximation, in this case implicit Euler, is used for the unknown error <span class="math notranslate nohighlight">\(\delta(t)\)</span>.
Combining each step in the time marching scheme into a vector results in the following matrix formulation</p>
<div class="math notranslate nohighlight">
\[\begin{eqnarray}
   \mathbf{F}\left(\mathbf{u}_0+\Delta t\mathbf{Q}\tilde{\mathbf{U}} + \Delta t\mathbf{Q}_\Delta\tilde{\mathbf{\delta}},\;\tilde{\mathbf{U}}+\tilde{\mathbf{\delta}},\;\mathbf{t}\right) = \mathbf{0}
\end{eqnarray}\]</div>
<p>with the integration matrix of the implicit Euler method</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{Q}_\Delta=
  \begin{pmatrix}
  \Delta t_1&amp;0&amp;\dots&amp;0&amp;0\\
  \Delta t_1&amp;\Delta t_2&amp;\dots&amp;0&amp;0\\
  .&amp;.&amp;\dots&amp;0&amp;0\\
  \Delta t_1&amp;\Delta t_2&amp;\dots&amp;\Delta t_{M-2}&amp;0\\
  \Delta t_1&amp;\Delta t_2&amp;\dots&amp;\Delta t_{M-2}&amp;\Delta t_{M-1}\\
  \end{pmatrix}\end{split}\]</div>
<p>Finally, the iterative nature of the method is made clear by considering that the approximate solution can be updated repeatedly with a <span class="math notranslate nohighlight">\(\tilde{\mathbf{\delta}}\)</span> that is recalculated after each iteration and using the previously updated solution as the initial condition for the next iteration. In this way, reformulation of the previous equation as</p>
<div class="math notranslate nohighlight">
\[\begin{eqnarray}
   \mathbf{F}\left(\mathbf{u}_0+\Delta t(\mathbf{Q}-\mathbf{Q}_\Delta)\tilde{\mathbf{U}} + \Delta t\mathbf{Q}_\Delta(\tilde{\mathbf{U}} + \tilde{\mathbf{\delta}}),\;\tilde{\mathbf{U}}+\tilde{\mathbf{\delta}},\;\mathbf{t}\right) = \mathbf{0}
\end{eqnarray}\]</div>
<p>results in the following iterative scheme</p>
<div class="math notranslate nohighlight">
\[\begin{eqnarray}
   \mathbf{F}\left(\mathbf{u}_0+\Delta t(\mathbf{Q}-\mathbf{Q}_\Delta)\mathbf{U}^{k}+ \Delta t\mathbf{Q}_\Delta\mathbf{U}^{k+1},\;\mathbf{U}^{k+1},\;\mathbf{t}\right) = \mathbf{0}.
\end{eqnarray}\]</div>
<p>In practice each iteration is carried out line by line and the resulting implicit equation for <span class="math notranslate nohighlight">\(U_{m+1}^{k+1}\)</span> is solved using the familiar <code class="docutils literal notranslate"><span class="pre">scipy.optimize.root()</span></code> function.</p>
</section>
<section id="how-to-implement-a-dae-problem-in-pysdc">
<h2>How to implement a DAE problem in pySDC?<a class="headerlink" href="#how-to-implement-a-dae-problem-in-pysdc" title="Link to this heading">¶</a></h2>
<p>Different from all other ODE problem classes in <code class="docutils literal notranslate"><span class="pre">pySDC</span></code> the DAE problem classes use the <em>yp-formulation</em> where the derivative is the unknown and the solution <span class="math notranslate nohighlight">\(u\)</span> is recovered using quadrature. Interested readers about the different formulations for spectral deferred corrections are referred to <a class="reference external" href="https://link.springer.com/article/10.1007/s10915-015-0146-9">Qu et al. (2015)</a>.</p>
<p>Let us consider the fully-implicit DAE</p>
<div class="math notranslate nohighlight">
\[\begin{split}y' (t) + \eta t z' (t) + (1 + \eta) z (t) &amp;= \cos (t) \\
y (t) + \eta t z (t) &amp;= \sin (t)\end{split}\]</div>
<p>which is of the general form</p>
<div class="math notranslate nohighlight">
\[\begin{eqnarray}
   F\left(u (t), u' (t), t\right) = 0
\end{eqnarray}\]</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">pySDC.projects.DAE.misc.problemDAE</span> <span class="kn">import</span> <span class="n">ProblemDAE</span>
<span class="kn">from</span> <span class="nn">pySDC.implementations.datatype_classes.mesh</span> <span class="kn">import</span> <span class="n">mesh</span>


<span class="k">class</span> <span class="nc">ProblematicF</span><span class="p">(</span><span class="n">ProblemDAE</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Standard example of a very simple fully implicit index-2 differential algebraic equation (DAE) that is not</span>
<span class="sd">    numerically solvable for certain choices of the parameter :math:`\eta`. The DAE system is given by</span>

<span class="sd">    .. math::</span>
<span class="sd">        \frac{d y(t)}{dt} + \eta t \frac{d z(t)}{dt} + (1 + \eta) z (t) = g (t).</span>

<span class="sd">    .. math::</span>
<span class="sd">        y (t) + \eta t z (t) = f(t),</span>

<span class="sd">    See, for example, page 264 of [1]_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nvars : int</span>
<span class="sd">        Number of unknowns of the system of DAEs.</span>
<span class="sd">    newton_tol : float</span>
<span class="sd">        Tolerance for Newton solver.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    eta : float</span>
<span class="sd">        Specific parameter of the problem.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] U. Ascher, L. R. Petzold. Computer method for ordinary differential equations and differential-algebraic</span>
<span class="sd">        equations. Society for Industrial and Applied Mathematics (1998).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dtype_u</span> <span class="o">=</span> <span class="n">mesh</span>
    <span class="n">dtype_f</span> <span class="o">=</span> <span class="n">mesh</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newton_tol</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialization routine&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">nvars</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">newton_tol</span><span class="o">=</span><span class="n">newton_tol</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_makeAttributeAndRegister</span><span class="p">(</span><span class="s1">&#39;eta&#39;</span><span class="p">,</span> <span class="n">localVars</span><span class="o">=</span><span class="nb">locals</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">eval_f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">du</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Routine to evaluate the implicit representation of the problem, i.e., :math:`F(u, u&#39;, t)`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        u : dtype_u</span>
<span class="sd">            Current values of the numerical solution at time t.</span>
<span class="sd">        du : dtype_u</span>
<span class="sd">            Current values of the derivative of the numerical solution at time t.</span>
<span class="sd">        t : float</span>
<span class="sd">            Current time of the numerical solution.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        f : dtype_f</span>
<span class="sd">            Current value of the right-hand side of f (which includes two components).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype_f</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">init</span><span class="p">)</span>
        <span class="n">f</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span> <span class="o">*</span> <span class="n">t</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">),</span>
            <span class="n">du</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span> <span class="o">*</span> <span class="n">t</span> <span class="o">*</span> <span class="n">du</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">work_counters</span><span class="p">[</span><span class="s1">&#39;rhs&#39;</span><span class="p">]()</span>
        <span class="k">return</span> <span class="n">f</span>

    <span class="k">def</span> <span class="nf">u_exact</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Routine for the exact solution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        t : float</span>
<span class="sd">            The time of the reference solution.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        me : dtype_u</span>
<span class="sd">            The reference solution as mesh object containing two components.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">me</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype_u</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">init</span><span class="p">)</span>
        <span class="n">me</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">me</span>

    <span class="k">def</span> <span class="nf">du_exact</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Routine for the derivative of the exact solution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        t : float</span>
<span class="sd">            The time of the reference solution.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        me : dtype_u</span>
<span class="sd">            The reference solution as mesh object containing two components.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">me</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype_u</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">init</span><span class="p">)</span>
        <span class="n">me</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">me</span>
</pre></div>
</div>
<p>The imports for the classes <code class="docutils literal notranslate"><span class="pre">ProblemDAE</span></code> and <code class="docutils literal notranslate"><span class="pre">mesh</span></code> are necessary for implementing this problem.</p>
<p>The problem class inherits from the parent <code class="docutils literal notranslate"><span class="pre">ProblemDAE</span></code> that
has the <code class="docutils literal notranslate"><span class="pre">solve_system</span></code> method solving the (non)-linear system to find the root, i.e., updating the values of the unknown derivative. All DAE problem classes should therefore inherit from this class.
For this general type of DAEs the datatype <code class="docutils literal notranslate"><span class="pre">mesh</span></code> is used here for both, <code class="docutils literal notranslate"><span class="pre">u</span></code> and <code class="docutils literal notranslate"><span class="pre">f</span></code>.
Further, the constructor requires at least the parameter <code class="docutils literal notranslate"><span class="pre">newton_tol</span></code>, the tolerance passed to the root solver. It is possible to set a default value (which is set to <code class="docutils literal notranslate"><span class="pre">1e-8</span></code> in the example above).</p>
<p><strong>Note:</strong> The name <code class="docutils literal notranslate"><span class="pre">newton_tol</span></code> could be confusing. The implicit system is not solved by Newton but rather by a root solver from <code class="docutils literal notranslate"><span class="pre">SciPy</span></code>. Different quasi-Newton methods can be chosen (see the [documentation](<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.root.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.root.html</a>)). Default here is <code class="docutils literal notranslate"><span class="pre">'hybr'</span></code> that uses modified Powell hybrid method. To change to solver it is possible to overload the <code class="docutils literal notranslate"><span class="pre">solve_system</span></code> method in a new implemented problem class.</p>
<p>Possibly other problem-specific parameters are needed. Our example class also needs a constant <code class="docutils literal notranslate"><span class="pre">eta</span></code> set to <span class="math notranslate nohighlight">\(1\)</span> and storing it as an attribute using <code class="docutils literal notranslate"><span class="pre">self._makeAttributeAndRegister('eta',</span> <span class="pre">localVars=locals())</span></code>.
The system of DAEs consists of two equations, i.e., two unknowns. Thus, the number of variables <code class="docutils literal notranslate"><span class="pre">nvars</span></code> needs to be set to <span class="math notranslate nohighlight">\(2\)</span>.</p>
<p>Implementing this system of equations the problem class also requires the <code class="docutils literal notranslate"><span class="pre">eval_f</span></code> method. As it can be seen, the method returns the right-hand side function <span class="math notranslate nohighlight">\(F\)</span> of the DAE in the way to have a function for which the root is sought.</p>
<p>Since the exact solution is known for this problem, the method <code class="docutils literal notranslate"><span class="pre">u_exact</span></code> returns it for each time <cite>t</cite>.</p>
<p>For Runge-Kutta methods, an initial condition for the derivatives at initial time <span class="math notranslate nohighlight">\(t_0\)</span> <span class="math notranslate nohighlight">\(y'(t_0)\)</span> and <span class="math notranslate nohighlight">\(z'(t_0)\)</span> are needed as well. They are implemented using the <code class="docutils literal notranslate"><span class="pre">du_exact</span></code> method.</p>
<p>The second large class of DAEs is the one of semi-explicit form</p>
<div class="math notranslate nohighlight">
\[\begin{split}y' (t) &amp;= f \left(y (t), z (t), t\right) \\
0 &amp;= g \left(y (t), z (t), t\right)\end{split}\]</div>
<p>which is also called a <em>constrained differential equation</em>. <span class="math notranslate nohighlight">\(y\)</span> is the differential variable and <span class="math notranslate nohighlight">\(z\)</span> denotes the algebraic variable since no corresponding integration is in the problem.
We want to implement such an equation and consider the example</p>
<div class="math notranslate nohighlight">
\[\begin{split}u_1' (t) &amp;= (\alpha - \frac{1}{2 - t}) u_1 (t) + (2 - t) \alpha z (t) + \frac{3 - t}{2 - t}, \\
u_2' (t) &amp;= \frac{1 - \alpha}{t - 2} u_1 (t) - u_2 (t) + (\alpha - 1) z (t) + 2 e^t, \\
0 &amp;= (t + 2) u_1 (t) + (t^2 - 4) u_2 (t) - (t^2 + t - 2) e^t.\end{split}\]</div>
<p>This example has two differential variables <span class="math notranslate nohighlight">\(u_1\)</span>, <span class="math notranslate nohighlight">\(u_2\)</span> (two differential equations) and one algebraic variable <span class="math notranslate nohighlight">\(z\)</span> (thus one algebraic equation).
In <code class="docutils literal notranslate"><span class="pre">pySDC</span></code> defining a problem class for semi-explicit DAEs is slightly different to those of fully-implicit form. Additionally to <code class="docutils literal notranslate"><span class="pre">numpy</span></code> for the example the imports for the classes <code class="docutils literal notranslate"><span class="pre">ProblemDAE</span></code> and <code class="docutils literal notranslate"><span class="pre">MeshDAE</span></code> are needed.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">pySDC.projects.DAE.misc.problemDAE</span> <span class="kn">import</span> <span class="n">ProblemDAE</span>


<span class="k">class</span> <span class="nc">SimpleDAE</span><span class="p">(</span><span class="n">ProblemDAE</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Example implementing a smooth linear index-2 differential-algebraic equation (DAE) with known analytical solution.</span>
<span class="sd">    The DAE system is given by</span>

<span class="sd">    .. math::</span>
<span class="sd">        \frac{d u_1 (t)}{dt} = (\alpha - \frac{1}{2 - t}) u_1 (t) + (2-t) \alpha z (t) + \frac{3 - t}{2 - t},</span>

<span class="sd">    .. math::</span>
<span class="sd">        \frac{d u_2 (t)}{dt} = \frac{1 - \alpha}{t - 2} u_1 (t) - u_2 (t) + (\alpha - 1) z (t) + 2 e^{t},</span>

<span class="sd">    .. math::</span>
<span class="sd">        0 = (t + 2) u_1 (t) + (t^{2} - 4) u_2 (t) - (t^{2} + t - 2) e^{t}.</span>

<span class="sd">    The exact solution of this system is</span>

<span class="sd">    .. math::</span>
<span class="sd">        u_1 (t) = u_2 (t) = e^{t},</span>

<span class="sd">    .. math::</span>
<span class="sd">        z (t) = -\frac{e^{t}}{2 - t}.</span>

<span class="sd">    This example is commonly used to test that numerical implementations are functioning correctly. See, for example,</span>
<span class="sd">    page 267 of [1]_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nvars : int</span>
<span class="sd">        Number of unknowns of the system of DAEs.</span>
<span class="sd">    newton_tol : float</span>
<span class="sd">        Tolerance for Newton solver.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] U. Ascher, L. R. Petzold. Computer method for ordinary differential equations and differential-algebraic</span>
<span class="sd">        equations. Society for Industrial and Applied Mathematics (1998).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newton_tol</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialization routine&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">nvars</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">newton_tol</span><span class="o">=</span><span class="n">newton_tol</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">eval_f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">du</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Routine to evaluate the implicit representation of the problem, i.e., :math:`F(u, u&#39;, t)`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        u : dtype_u</span>
<span class="sd">            Current values of the numerical solution at time t.</span>
<span class="sd">        du : dtype_u</span>
<span class="sd">            Current values of the derivative of the numerical solution at time t.</span>
<span class="sd">        t : float</span>
<span class="sd">            Current time of the numerical solution.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        f : dtype_f</span>
<span class="sd">            Current value of the right-hand side of f (which includes three components).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Smooth index-2 DAE pg. 267 Ascher and Petzold (also the first example in KDC Minion paper)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mf">10.0</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype_f</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">init</span><span class="p">)</span>

        <span class="n">f</span><span class="o">.</span><span class="n">diff</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="o">-</span><span class="n">du</span><span class="o">.</span><span class="n">diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="n">t</span><span class="p">))</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">alg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">t</span><span class="p">),</span>
            <span class="o">-</span><span class="n">du</span><span class="o">.</span><span class="n">diff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="o">.</span><span class="n">diff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">alg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">t</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">alg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">diff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">t</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">t</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">work_counters</span><span class="p">[</span><span class="s1">&#39;rhs&#39;</span><span class="p">]()</span>
        <span class="k">return</span> <span class="n">f</span>

    <span class="k">def</span> <span class="nf">u_exact</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Routine for the exact solution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        t : float</span>
<span class="sd">            The time of the reference solution.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        me : dtype_u</span>
<span class="sd">            The reference solution as mesh object containing three components.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">me</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype_u</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">init</span><span class="p">)</span>
        <span class="n">me</span><span class="o">.</span><span class="n">diff</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
        <span class="n">me</span><span class="o">.</span><span class="n">alg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">me</span>

    <span class="k">def</span> <span class="nf">du_exact</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Routine for the derivative of the exact solution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        t : float</span>
<span class="sd">            The time of the reference solution.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        me : dtype_u</span>
<span class="sd">            The reference solution as mesh object containing three components.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">me</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype_u</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">init</span><span class="p">)</span>
        <span class="n">me</span><span class="o">.</span><span class="n">diff</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
        <span class="n">me</span><span class="o">.</span><span class="n">alg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="mi">3</span><span class="p">))</span> <span class="o">/</span> <span class="p">((</span><span class="mi">2</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">me</span>
</pre></div>
</div>
<p>This problem class inherits again from <code class="docutils literal notranslate"><span class="pre">ProblemDAE</span></code>. In contrast, for the solution <code class="docutils literal notranslate"><span class="pre">u</span></code> and the right-hand side of the <code class="docutils literal notranslate"><span class="pre">f</span></code>
a different datatype <code class="docutils literal notranslate"><span class="pre">MeshDAE</span></code> is used that allows to separate between the differential variables and the algebraic variables as well
as for the equations. The tolerance for the root solver is passed with a default value of <code class="docutils literal notranslate"><span class="pre">1e-10</span></code> and the number of unknowns is <span class="math notranslate nohighlight">\(3\)</span>, i.e., <code class="docutils literal notranslate"><span class="pre">nvars=3</span></code>.
The problem-specific parameter <code class="docutils literal notranslate"><span class="pre">a</span></code> has a default value of <code class="docutils literal notranslate"><span class="pre">10.0</span></code>.</p>
<p>In the <code class="docutils literal notranslate"><span class="pre">eval_f</span></code> method the equations and the variables are now separated using the components of the <code class="docutils literal notranslate"><span class="pre">MeshDAE</span></code>. Recall that <code class="docutils literal notranslate"><span class="pre">eval_f</span></code> returns the right-hand side function so that we have a root problem. However, for this semi-explicit DAE this is not the case, but we can change that by rewriting the system to</p>
<div class="math notranslate nohighlight">
\[\begin{split}0 &amp;= f \left(y (t), z (t), t\right) - y' (t) \\
0 &amp;= g \left(y (t), z (t), t\right).\end{split}\]</div>
<p>In the example above the differential variables are <span class="math notranslate nohighlight">\(u_1\)</span> and <span class="math notranslate nohighlight">\(u_2\)</span> which can be accessed using <code class="docutils literal notranslate"><span class="pre">u.diff[0]</span></code> and <code class="docutils literal notranslate"><span class="pre">u.diff[1]</span></code>.
The algebraic variable <span class="math notranslate nohighlight">\(z\)</span> is stored in <code class="docutils literal notranslate"><span class="pre">u.alg[0]</span></code>. The corresponding derivatives for <span class="math notranslate nohighlight">\(u_1\)</span> and <span class="math notranslate nohighlight">\(u_2\)</span> are stored in <code class="docutils literal notranslate"><span class="pre">du.diff[0]</span></code> and <code class="docutils literal notranslate"><span class="pre">du.diff[1]</span></code>.
It is also possible to separate the differential and algebraic equations by assigning the corresponding equations to <code class="docutils literal notranslate"><span class="pre">f.diff[0]</span></code> and <code class="docutils literal notranslate"><span class="pre">f.diff[1]</span></code>, and <code class="docutils literal notranslate"><span class="pre">f.alg[0]</span></code>, respectively.</p>
<p>In the same way the method <code class="docutils literal notranslate"><span class="pre">u_exact</span></code> to access the exact solution can be implemented.</p>
<p>This example class also have an <code class="docutils literal notranslate"><span class="pre">du_exact</span></code> method to implement initial conditions for <span class="math notranslate nohighlight">\(u_1'(t_0)\)</span>, <span class="math notranslate nohighlight">\(u_2'(t_0)\)</span>, and <span class="math notranslate nohighlight">\(z'(t_0)\)</span>.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Solving differential algebraic equations with SDC</a><ul>
<li><a class="reference internal" href="#project-overview">Project overview</a></li>
<li><a class="reference internal" href="#theoretical-details">Theoretical details</a></li>
<li><a class="reference internal" href="#how-to-implement-a-dae-problem-in-pysdc">How to implement a DAE problem in pySDC?</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="Resilience.html"
                          title="previous chapter">Resilience in SDC</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="compression.html"
                          title="next chapter">Compression in pySDC</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/projects/DAE.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="compression.html" title="Compression in pySDC"
             >next</a> |</li>
        <li class="right" >
          <a href="Resilience.html" title="Resilience in SDC"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">pySDC 5.5.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Solving differential algebraic equations with SDC</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2024, Robert Speck.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.0.0.
    </div>
  </body>
</html>