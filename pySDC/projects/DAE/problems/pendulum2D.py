from pySDC.projects.DAE.misc.ProblemDAE import ptype_dae


class pendulum_2d(ptype_dae):
    r"""
    Example implementing the well known 2D pendulum as a first order differential-algebraic equation (DAE) of index 3.
    The DAE system is given by the equations

    .. math::
        \frac{dp}{dt} = u,

    .. math::
        \frac{dq}{dt} = v,

    .. math::
        m\frac{du}{dt} = -p \lambda,

    .. math::
        m\frac{dv}{dt} = -q \lambda - g,

    .. math::
        0 = p^2 + q^2 - l^2

    for :math:`l=1` and :math:`m=1`. The pendulum is used in most introductory literature on DAEs, for example on page 8
    of [1]_.

    Parameters
    ----------
    nvars : int
        Number of unknowns of the system of DAEs.
    newton_tol : float
        Tolerance for Newton solver.

    Attributes
    ----------
    t_end: float
        The end time at which the reference solution is determined.

    References
    ----------
    .. [1] E. Hairer, C. Lubich, M. Roche. The numerical solution of differential-algebraic systems by Runge-Kutta methods.
        Lect. Notes Math. (1989).
    """

    def __init__(self, newton_tol):
        """Initialization routine"""
        super().__init__(nvars=5, newton_tol=newton_tol)
        # load reference solution
        # data file must be generated and stored under misc/data and self.t_end = t[-1]
        # data = np.load(r'pySDC/projects/DAE/misc/data/pendulum.npy')
        # t = data[:, 0]
        # solution = data[:, 1:]
        # self.u_ref = interp1d(t, solution, kind='cubic', axis=0, fill_value='extrapolate')
        self.t_end = 0.0

    def eval_f(self, u, du, t):
        r"""
        Routine to evaluate the implicit representation of the problem, i.e., :math:`F(u, u', t)`.

        Parameters
        ----------
        u : dtype_u
            Current values of the numerical solution at time t.
        du : dtype_u
            Current values of the derivative of the numerical solution at time t.
        t : float
            Current time of the numerical solution.

        Returns
        -------
        f : dtype_f
            Current value of the right-hand side of f (which includes five components).
        """
        g = 9.8
        # The last element of u is a Lagrange multiplier. Not sure if this needs to be time dependent, but must model the
        # weight somehow
        f = self.dtype_f(self.init)
        f.diff[:4] = (
            du.diff[0] - u.diff[2],
            du.diff[1] - u.diff[3],
            du.diff[2] + u.alg[0] * u.diff[0],
            du.diff[3] + u.alg[0] * u.diff[1] + g,
        )
        f.alg[0] = u.diff[0] ** 2 + u.diff[1] ** 2 - 1
        self.work_counters['rhs']()
        return f

    def u_exact(self, t):
        """
        Approximation of the exact solution generated by spline interpolation of an extremely accurate numerical reference solution.

        Parameters
        ----------
        t : float
            The time of the reference solution.

        Returns
        -------
        me : dtype_u
            The reference solution as mesh object. It contains fixed initial conditions at initial time.
        """
        me = self.dtype_u(self.init)
        if t == 0:
            me.diff[:4] = (-1, 0, 0, 0)
            me.alg[0] = 0
        elif t < self.t_end:
            u_ref = self.u_ref(t)
            me.diff[:4] = u_ref[:4]
            me.alg[0] = u_ref[5]
        else:
            self.logger.warning("Requested time exceeds domain of the reference solution. Returning zero.")
            me.diff[:4] = (0, 0, 0, 0)
            me.alg[0] = 0
        return me
