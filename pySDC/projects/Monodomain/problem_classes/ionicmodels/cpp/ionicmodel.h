#ifndef IONICMODEL
#define IONICMODEL

// The ionic model codes are partially generated by myokit, which uses this NV_Ith_S function to access the elements of the array in their data type.
// In our implementation we use the [] operator to access the elements of the array so we define this function as a wrapper and avoid changing the original code.
double inline NV_Ith_S(double *y, unsigned i)
{
    return y[i];
}

double inline phi_f_from_lmbda_yinf(double y, double lmbda, double yinf, double dt)
{
    return ((exp(dt * lmbda) - 1.) / dt) * (y - yinf);
}

double inline phi_f_from_tau_yinf(double y, double tau, double yinf, double dt)
{
    return ((exp(-dt / tau) - 1.) / dt) * (y - yinf);
}

void get_raw_data(py::array_t<double> &x, double **array_ptrs, size_t &N, size_t &n_dofs)
{
    auto r = x.unchecked<2>();
    N = r.shape(0);
    n_dofs = r.shape(1);
    for (py::ssize_t i = 0; i < r.shape(0); i++)
        array_ptrs[i] = (double *)r.data(i, 0);
};

void assign(py::list l, std::initializer_list<int> a)
{
    for (auto a_el : a)
        l.append(a_el);
};

class IonicModel
{
public:
    IonicModel(const double scale_);

    py::list f_expl_args;
    py::list f_exp_args;
    py::list f_expl_indeces;
    py::list f_exp_indeces;
    py::list get_f_expl_args() { return f_expl_args; };
    py::list get_f_exp_args() { return f_exp_args; };
    py::list get_f_expl_indeces() { return f_expl_indeces; };
    py::list get_f_exp_indeces() { return f_exp_indeces; };
    size_t get_size() { return size; };

protected:
    double scale;
    size_t size;
};

IonicModel::IonicModel(const double scale_)
{
    scale = scale_;
}

#endif