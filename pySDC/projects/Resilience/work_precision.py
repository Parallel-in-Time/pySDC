from mpi4py import MPI
import numpy as np
import matplotlib.pyplot as plt
import pickle
import logging
from time import perf_counter
import copy

from pySDC.projects.Resilience.strategies import merge_descriptions
from pySDC.projects.Resilience.Lorenz import run_Lorenz
from pySDC.projects.Resilience.vdp import run_vdp
from pySDC.projects.Resilience.Schroedinger import run_Schroedinger
from pySDC.projects.Resilience.quench import run_quench
from pySDC.projects.Resilience.AC import run_AC
from pySDC.projects.Resilience.RBC import run_RBC
from pySDC.projects.Resilience.GS import run_GS

from pySDC.helpers.stats_helper import get_sorted, filter_stats
from pySDC.helpers.plot_helper import setup_mpl, figsize_by_journal

setup_mpl(reset=True)
LOGGER_LEVEL = 25
LOG_TO_FILE = False

logging.getLogger('matplotlib.texmanager').setLevel(90)

Tends = {'run_RBC': 16.0, 'run_Lorenz': 2.0}
t0s = {
    'run_RBC': 10.0,
}


def std_log(x):
    return np.std(np.log(x))


MAPPINGS = {
    'e_global': ('e_global_post_run', max, False),
    'e_global_rel': ('e_global_rel_post_run', max, False),
    't': ('timing_run', max, False),
    # 'e_local_max': ('e_local_post_step', max, False),
    'k_SDC': ('k', sum, None),
    'k_SDC_no_restart': ('k', sum, False),
    'k_Newton': ('work_newton', sum, None),
    'k_linear': ('work_linear', sum, None),
    'k_Newton_no_restart': ('work_newton', sum, False),
    'k_rhs': ('work_rhs', sum, None),
    'k_factorizations': ('work_factorizations', sum, None),
    'num_steps': ('dt', len, None),
    'restart': ('restart', sum, None),
    'dt_mean': ('dt', np.mean, False),
    'dt_max': ('dt', max, False),
    'dt_min': ('dt', min, False),
    'dt_sigma': ('dt', std_log, False),
    'e_embedded_max': ('error_embedded_estimate', max, False),
    'u0_increment_max': ('u0_increment', max, None),
    'u0_increment_mean': ('u0_increment', np.mean, None),
    'u0_increment_max_no_restart': ('u0_increment', max, False),
    'u0_increment_mean_no_restart': ('u0_increment', np.mean, False),
}

logger = logging.getLogger('WorkPrecision')
logger.setLevel(LOGGER_LEVEL)


def get_forbidden_combinations(problem, strategy, **kwargs):
    """
    Check if the combination of strategy and problem is forbidden

    Args:
        problem (function): A problem to run
        strategy (Strategy): SDC strategy
    """
    if strategy.name == 'ERK':
        if problem.__name__ in ['run_quench', 'run_Schroedinger', 'run_AC']:
            return True

    return False


def single_run(
    problem,
    strategy,
    data,
    custom_description,
    num_procs=1,
    comm_world=None,
    problem_args=None,
    hooks=None,
    Tend=None,
    num_procs_sweeper=1,
):
    """
    Make a single run of a particular problem with a certain strategy.

    Args:
        problem (function): A problem to run
        strategy (Strategy): SDC strategy
        data (dict): Put the results in here
        custom_description (dict): Overwrite presets
        num_procs (int): Number of processes for the time communicator
        comm_world (mpi4py.MPI.Intracomm): Communicator that is available for the entire script
        hooks (list): List of additional hooks
        num_procs_sweeper (int): Number of processes for the sweeper

    Returns:
        dict: Stats generated by the run
    """
    from pySDC.implementations.hooks.log_errors import LogGlobalErrorPostRun
    from pySDC.implementations.hooks.log_work import LogWork
    from pySDC.projects.Resilience.hook import LogData

    hooks = hooks if hooks else []

    t_last = perf_counter()

    num_procs_tot = num_procs * num_procs_sweeper
    comm = comm_world.Split(comm_world.rank < num_procs_tot)
    if comm_world.rank >= num_procs_tot:
        comm.Free()
        return None

    # make communicators for time and sweepers
    comm_time = comm.Split(comm.rank // num_procs)
    comm_sweep = comm.Split(comm_time.rank)

    if comm_time.size < num_procs:
        raise Exception(f'Need at least {num_procs*num_procs_sweeper} processes, got only {comm.size}')

    strategy_description = strategy.get_custom_description(problem, num_procs)
    description = merge_descriptions(strategy_description, custom_description)
    if comm_sweep.size > 1:
        description['sweeper_params']['comm'] = comm_sweep

    controller_params = {
        'logger_level': LOGGER_LEVEL,
        'log_to_file': LOG_TO_FILE,
        'fname': 'out.txt',
        **strategy.get_controller_params(),
    }
    problem_args = {} if problem_args is None else problem_args

    Tend = Tends.get(problem.__name__, None) if Tend is None else Tend
    t0 = t0s.get(problem.__name__, None)

    stats, controller, crash = problem(
        custom_description=description,
        Tend=strategy.get_Tend(problem, num_procs) if Tend is None else Tend,
        hook_class=[LogData, LogWork, LogGlobalErrorPostRun] + hooks,
        custom_controller_params=controller_params,
        use_MPI=True,
        t0=t0,
        comm=comm_time,
        **problem_args,
    )

    t_now = perf_counter()
    logger.debug(f'Finished run in {t_now - t_last:.2e} s')
    t_last = perf_counter()

    # record all the metrics
    if comm_sweep.size > 1:
        try:
            stats_all = filter_stats(stats, comm=comm_sweep)
        except MPI.Exception:
            for key in MAPPINGS.keys():
                data[key] += [np.nan]
            return stats

    else:
        stats_all = stats
    comm_sweep.Free()

    for key, mapping in MAPPINGS.items():
        if crash:
            data[key] += [np.nan]
            continue
        me = get_sorted(stats_all, comm=comm_time, type=mapping[0], recomputed=mapping[2])
        if len(me) == 0:
            data[key] += [np.nan]
        else:
            data[key] += [mapping[1]([you[1] for you in me])]

    t_now = perf_counter()
    logger.debug(f'Recorded all data after {t_now - t_last:.2e} s')
    t_last = perf_counter()

    comm_time.Free()
    comm.Free()
    return stats


def get_parameter(dictionary, where):
    """
    Get a parameter at a certain position in a dictionary of dictionaries.

    Args:
        dictionary (dict): The dictionary
        where (list): The list of keys leading to the value you want

    Returns:
        The value of the dictionary
    """
    if len(where) == 1:
        return dictionary[where[0]]
    else:
        return get_parameter(dictionary[where[0]], where[1:])


def set_parameter(dictionary, where, parameter):
    """
    Set a parameter at a certain position in a dictionary of dictionaries

    Args:
        dictionary (dict): The dictionary
        where (list): The list of keys leading to the value you want to set
        parameter: Whatever you want to set the parameter to

    Returns:
        None
    """
    if len(where) == 1:
        dictionary[where[0]] = parameter
    else:
        set_parameter(dictionary[where[0]], where[1:], parameter)


def get_path(problem, strategy, num_procs, handle='', base_path='data/work_precision', num_procs_sweeper=1, mode=''):
    """
    Get the path to a certain data.

    Args:
        problem (function): A problem to run
        strategy (Strategy): SDC strategy
        num_procs (int): Number of processes for the time communicator
        handle (str): The name of the configuration
        base_path (str): Some path where all the files are stored
        num_procs_sweeper (int): Number of processes for the sweeper
        mode (str): The mode this was generated for

    Returns:
        str: The path to the data you are looking for
    """
    return f'{base_path}/{problem.__name__}-{strategy.__class__.__name__}-{handle}{"-wp" if handle else "wp"}-{num_procs}-{num_procs_sweeper}procs-{mode}.pickle'


def record_work_precision(
    problem,
    strategy,
    num_procs=1,
    custom_description=None,
    handle='',
    runs=1,
    comm_world=None,
    problem_args=None,
    param_range=None,
    Tend=None,
    hooks=None,
    num_procs_sweeper=1,
    mode='',
):
    """
    Run problem with strategy and record the cost parameters.

    Args:
        problem (function): A problem to run
        strategy (Strategy): SDC strategy
        num_procs (int): Number of processes for the time communicator
        custom_description (dict): Overwrite presets
        handle (str): The name of the configuration
        runs (int): Number of runs you want to do
        comm_world (mpi4py.MPI.Intracomm): Communicator that is available for the entire script
        num_procs_sweeper (int): Number of processes for the sweeper

    Returns:
        None
    """
    if get_forbidden_combinations(problem, strategy):
        return None

    data = {}

    # prepare precision parameters
    param = strategy.precision_parameter
    description = merge_descriptions(
        strategy.get_custom_description(problem, num_procs),
        {} if custom_description is None else custom_description,
    )
    if param == 'e_tol':
        power = 10.0
        set_parameter(description, strategy.precision_parameter_loc[:-1] + ['dt_min'], 0)
        exponents = [-3, -2, -1, 0, 1, 2, 3][::-1]
        if problem.__name__ == 'run_vdp':
            if type(strategy).__name__ in ["AdaptivityPolynomialError"]:
                exponents = [0, 1, 2, 3, 5][::-1]
            else:
                exponents = [-3, -2, -1, 0, 0.2, 0.8, 1][::-1]
        if problem.__name__ == 'run_RBC':
            exponents = [1, 0, -0.5, -1, -2]
        if problem.__name__ == 'run_GS':
            exponents = [-2, -1, 0, 1, 2, 3][::-1]
        if problem.__name__ == 'run_Lorenz':
            exponents = [0, 1, 2, 3][::-1]
            if type(strategy).__name__ in ["AdaptivityStrategy"]:
                exponents = [0, 1, 2, 3, 4, 5][::-1]
    elif param == 'dt':
        power = 2.0
        exponents = [-1, 0, 1, 2, 3][::-1]
    elif param == 'restol':
        power = 10.0
        exponents = [-2, -1, 0, 1, 2, 3]
        if problem.__name__ == 'run_vdp':
            exponents = [-4, -3, -2, -1, 0, 1]
    elif param == 'cfl':
        power = 2
        exponents = [-3, -2, -1, 0, 1]
    else:
        raise NotImplementedError(f"I don't know how to get default value for parameter \"{param}\"")

    where = strategy.precision_parameter_loc
    default = get_parameter(description, where)
    param_range = [default * power**i for i in exponents] if param_range is None else param_range

    if problem.__name__ == 'run_quench':
        if param == 'restol':
            param_range = [1e-5, 1e-6, 1e-7, 1e-8, 1e-9]
        elif param == 'dt':
            param_range = [1.25, 2.5, 5.0, 10.0, 20.0][::-1]
    if problem.__name__ == 'run_RBC':
        if param == 'dt':
            param_range = [8e-2, 6e-2, 4e-2, 3e-2, 2e-2]
    if problem.__name__ == 'run_GS':
        if param == 'dt':
            param_range = [2, 1, 0.5, 0.1]
    if problem.__name__ == 'run_Lorenz':
        if param == 'dt':
            param_range = [5e-2, 2e-2, 1e-2, 5e-3]

    # run multiple times with different parameters
    for i in range(len(param_range)):
        set_parameter(description, where, param_range[i])

        data[param_range[i]] = {key: [] for key in MAPPINGS.keys()}
        data[param_range[i]]['param'] = [param_range[i]]
        data[param_range[i]][param] = [param_range[i]]

        description = merge_descriptions(
            descA=description, descB=strategy.get_description_for_tolerance(problem=problem, param=param_range[i])
        )
        for _j in range(runs):
            if comm_world.rank == 0:
                logger.log(
                    24,
                    f'Starting: {problem.__name__}: {strategy} {handle} {num_procs}-{num_procs_sweeper} procs, {param}={param_range[i]:.2e}',
                )
            single_run(
                problem,
                strategy,
                data[param_range[i]],
                custom_description=description,
                comm_world=comm_world,
                problem_args=problem_args,
                num_procs=num_procs,
                hooks=hooks,
                Tend=Tend,
                num_procs_sweeper=num_procs_sweeper,
            )

            comm_world.Barrier()

            if comm_world.rank == 0:
                if np.isfinite(data[param_range[i]]["k_linear"][-1]):
                    k_type = "k_linear"
                elif np.isfinite(data[param_range[i]]["k_Newton"][-1]):
                    k_type = 'k_Newton'
                else:
                    k_type = "k_SDC"
                logger.log(
                    25,
                    f'{problem.__name__}: {strategy} {handle} {num_procs}-{num_procs_sweeper} procs, {param}={param_range[i]:.2e}: e={data[param_range[i]]["e_global"][-1]}, t={data[param_range[i]]["t"][-1]}, {k_type}={data[param_range[i]][k_type][-1]}',
                )

    if comm_world.rank == 0:
        import socket
        import time

        data['meta'] = {
            'hostname': socket.gethostname(),
            'time': time.time,
            'runs': runs,
        }
        path = get_path(problem, strategy, num_procs, handle, num_procs_sweeper=num_procs_sweeper, mode=mode)
        with open(path, 'wb') as f:
            logger.debug(f'Dumping file \"{path}\"')
            pickle.dump(data, f)
        return data


def load(**kwargs):
    """
    Load stored data. Arguments are passed on to `get_path`

    Returns:
        dict: The data
    """
    path = get_path(**kwargs)
    with open(path, 'rb') as f:
        logger.debug(f'Loading file \"{path}\"')
        data = pickle.load(f)
    return data


def extract_data(data, work_key, precision_key):
    """
    Get the work and precision from a data object.

    Args:
        data (dict): Data from work-precision measurements
        work_key (str): Name of variable on x-axis
        precision_key (str): Name of variable on y-axis

    Returns:
        numpy array: Work
        numpy array: Precision
    """
    keys = [key for key in data.keys() if key not in ['meta']]
    work = [np.nanmean(data[key][work_key]) for key in keys]
    precision = [np.nanmean(data[key][precision_key]) for key in keys]
    return np.array(work), np.array(precision)


def get_order(work_key='e_global', precision_key='param', strategy=None, handle=None, **kwargs):
    data = load(**kwargs, strategy=strategy, handle=handle)
    work, precision = extract_data(data, work_key, precision_key)

    order = [np.log(precision[i + 1] / precision[i]) / np.log(work[i + 1] / work[i]) for i in range(len(work) - 1)]

    print(f'Order for {strategy} {handle}: {np.mean(order):.2f}')


def plot_work_precision(
    problem,
    strategy,
    num_procs,
    ax,
    work_key='k_SDC',
    precision_key='e_global',
    handle='',
    plotting_params=None,
    comm_world=None,
    num_procs_sweeper=1,
    mode='',
):  # pragma: no cover
    """
    Plot data from running a problem with a strategy.

    Args:
        problem (function): A problem to run
        strategy (Strategy): SDC strategy
        num_procs (int): Number of processes for the time communicator
        ax (matplotlib.pyplot.axes): Somewhere to plot
        work_key (str): The key in the recorded data you want on the x-axis
        precision_key (str): The key in the recorded data you want on the y-axis
        handle (str): The name of the configuration
        plotting_params (dict): Will be passed when plotting
        comm_world (mpi4py.MPI.Intracomm): Communicator that is available for the entire script
        num_procs_sweeper (int): Number of processes for the sweeper
        mode (str): The of the configurations you want to retrieve

    Returns:
        None
    """
    if comm_world.rank > 0 or get_forbidden_combinations(problem, strategy):
        return None

    data = load(
        problem=problem,
        strategy=strategy,
        num_procs=num_procs,
        handle=handle,
        num_procs_sweeper=num_procs_sweeper,
        mode=mode,
    )

    work, precision = extract_data(data, work_key, precision_key)
    keys = [key for key in data.keys() if key not in ['meta']]

    for key in [work_key, precision_key]:
        rel_variance = [np.std(data[me][key]) / max([np.nanmean(data[me][key]), 1.0]) for me in keys]
        if not all(me < 1e-1 or not np.isfinite(me) for me in rel_variance):
            logger.warning(
                f"Variance in \"{key}\" for {get_path(problem, strategy, num_procs, handle, num_procs_sweeper=num_procs_sweeper, mode=mode)} too large! Got {rel_variance}"
            )

    style = merge_descriptions(
        {**strategy.style, 'label': f'{strategy.style["label"]}{f" {handle}" if handle else ""}'},
        plotting_params if plotting_params else {},
    )

    mask = np.logical_and(np.isfinite(work), np.isfinite(precision))
    ax.loglog(work[mask], precision[mask], **style)

    # get_order(
    #     problem=problem,
    #     strategy=strategy,
    #     num_procs=num_procs,
    #     handle=handle,
    #     work_key=work_key,
    #     precision_key=precision_key,
    # )

    if 't' in [work_key, precision_key]:
        meta = data.get('meta', {})

        if meta.get('hostname', None) in ['thomas-work']:
            ax.text(0.1, 0.1, "Laptop timings!", transform=ax.transAxes)
        if meta.get('runs', None) == 1:
            ax.text(0.1, 0.2, "No sampling!", transform=ax.transAxes)

    if problem.__name__ == 'run_vdp':
        if mode == 'parallel_efficiency':
            # ax.set_xticks([6e-1, 2e0])
            ax.set_xticks(
                ticks=[
                    0.4,
                    5e-1,
                    6e-1,
                    7e-1,
                    8e-1,
                    9e-1,
                    2e0,
                ],
                labels=['']
                + [r'$5\times 10^{-1}$']
                + [
                    '',
                ]
                * 4
                + [r'$2\times 10^0$'],
                minor=True,
            )
        elif mode == 'RK_comp':
            ax.set_xticks(
                ticks=[
                    5e-1,
                    6e-1,
                    7e-1,
                    8e-1,
                    9e-1,
                    2e0,
                ],
                labels=[r'$5\times 10^{-1}$']
                + [
                    '',
                ]
                * 4
                + [r'$2\times 10^0$'],
                minor=True,
            )
    elif problem.__name__ == 'run_quench':
        if mode == 'RK_comp':
            ax.set_xticks(
                ticks=[
                    0.2,
                    0.3,
                    0.4,
                    5e-1,
                    6e-1,
                    7e-1,
                    8e-1,
                    9e-1,
                    2e0,
                ],
                labels=['']
                + [r'$3\times 10^{-1}$']
                + [
                    '',
                ]
                * 7,
                minor=True,
            )


def plot_parallel_efficiency_diagonalSDC(
    ax, work_key, precision_key, num_procs_sweeper, num_procs=1, **kwargs
):  # pragma: no cover
    serial_data = load(
        num_procs=num_procs,
        num_procs_sweeper=1,
        **kwargs,
    )
    parallel_data = load(
        num_procs=num_procs,
        num_procs_sweeper=num_procs_sweeper,
        **kwargs,
    )
    serial_work, serial_precision = extract_data(serial_data, work_key, precision_key)
    parallel_work, parallel_precision = extract_data(parallel_data, work_key, precision_key)
    # assert np.allclose(serial_precision, parallel_precision)

    serial_work = np.asarray(serial_work)
    parallel_work = np.asarray(parallel_work)

    # ax.loglog(serial_work, serial_precision)
    # ax.loglog(parallel_work, parallel_precision)

    speedup = serial_work / parallel_work
    parallel_efficiency = np.median(speedup) / num_procs_sweeper
    ax.plot(serial_precision, speedup)
    ax.set_xscale('log')
    ax.set_ylabel('speedup')

    if 't' in [work_key, precision_key]:
        meta = parallel_data.get('meta', {})

        if meta.get('hostname', None) in ['thomas-work']:
            ax.text(0.1, 0.1, "Laptop timings!", transform=ax.transAxes)
        if meta.get('runs', None) == 1:
            ax.text(0.1, 0.2, "No sampling!", transform=ax.transAxes)

    return np.median(speedup), parallel_efficiency


def decorate_panel(ax, problem, work_key, precision_key, num_procs=1, title_only=False):  # pragma: no cover
    """
    Decorate a plot

    Args:
        ax (matplotlib.pyplot.axes): Somewhere to plot
        problem (function): A problem to run
        work_key (str): The key in the recorded data you want on the x-axis
        precision_key (str): The key in the recorded data you want on the y-axis
        num_procs (int): Number of processes for the time communicator
        title_only (bool): Put only the title on top, or do the whole shebang

    Returns:
        None
    """
    labels = {
        'k_SDC': 'SDC iterations',
        'k_SDC_no_restart': 'SDC iterations (restarts excluded)',
        'k_Newton': 'Newton iterations',
        'k_Newton_no_restart': 'Newton iterations (restarts excluded)',
        'k_rhs': 'right hand side evaluations',
        'k_factorizations': 'matrix factorizations',
        't': 'wall clock time / s',
        'e_global': 'global error',
        'e_global_rel': 'relative global error',
        'e_local_max': 'max. local error',
        'restart': 'restarts',
        'dt_max': r'$\Delta t_\mathrm{max}$',
        'dt_min': r'$\Delta t_\mathrm{min}$',
        'dt_sigma': r'$\sigma(\Delta t)$',
        'dt_mean': r'$\bar{\Delta t}$',
        'param': 'accuracy parameter',
        'u0_increment_max': r'$\| \Delta u_0 \|_{\infty} $',
        'u0_increment_mean': r'$\bar{\Delta u_0}$',
        'u0_increment_max_no_restart': r'$\| \Delta u_0 \|_{\infty} $ (restarts excluded)',
        'u0_increment_mean_no_restart': r'$\bar{\Delta u_0}$ (restarts excluded)',
        'k_linear': 'Linear solver iterations',
        'speedup': 'Speedup',
        'nprocs': r'$N_\mathrm{procs}$',
        '': '',
    }

    if not title_only:
        ax.set_xlabel(labels.get(work_key, 'work'))
        ax.set_ylabel(labels.get(precision_key, 'precision'))
        # ax.legend(frameon=False)

    titles = {
        'run_vdp': 'Van der Pol',
        'run_Lorenz': 'Lorenz attractor',
        'run_Schroedinger': r'Schr\"odinger',
        'run_quench': 'Quench',
        'run_AC': 'Allen-Cahn',
        'run_RBC': 'Rayleigh-Benard',
        'run_GS': 'Gray-Scott',
    }
    ax.set_title(titles.get(problem.__name__, ''))


def execute_configurations(
    problem,
    configurations,
    work_key,
    precision_key,
    num_procs,
    ax,
    decorate,
    record,
    runs,
    comm_world,
    plotting,
    Tend=None,
    num_procs_sweeper=1,
    mode='',
):
    """
    Run for multiple configurations.

    Args:
        problem (function): A problem to run
        configurations (dict): The configurations you want to run with
        work_key (str): The key in the recorded data you want on the x-axis
        precision_key (str): The key in the recorded data you want on the y-axis
        num_procs (int): Number of processes for the time communicator
        ax (matplotlib.pyplot.axes): Somewhere to plot
        decorate (bool): Whether to decorate fully or only put the title
        record (bool): Whether to only plot or also record the data first
        runs (int): Number of runs you want to do
        comm_world (mpi4py.MPI.Intracomm): Communicator that is available for the entire script
        plotting (bool): Whether to plot something
        num_procs_sweeper (int): Number of processes for the sweeper
        mode (str): What you want to look at

    Returns:
        None
    """
    for _, config in configurations.items():
        for strategy in config['strategies']:
            shared_args = {
                'problem': problem,
                'strategy': strategy,
                'handle': config.get('handle', ''),
                'num_procs': config.get('num_procs', num_procs),
                'num_procs_sweeper': config.get('num_procs_sweeper', num_procs_sweeper),
            }
            if record:
                logger.debug('Recording work precision')
                record_work_precision(
                    **shared_args,
                    custom_description=config.get('custom_description', {}),
                    runs=runs,
                    comm_world=comm_world,
                    problem_args=config.get('problem_args', {}),
                    param_range=config.get('param_range', None),
                    hooks=config.get('hooks', None),
                    Tend=config.get('Tend') if Tend is None else Tend,
                    mode=mode,
                )
            if plotting and comm_world.rank == 0:
                logger.debug('Plotting')
                plot_work_precision(
                    **shared_args,
                    work_key=work_key,
                    precision_key=precision_key,
                    ax=ax,
                    plotting_params=config.get('plotting_params', {}),
                    comm_world=comm_world,
                    mode=mode,
                )

    if comm_world.rank == 0:
        decorate_panel(
            ax=ax,
            problem=problem,
            work_key=work_key,
            precision_key=precision_key,
            num_procs=num_procs,
            title_only=not decorate,
        )


def get_configs(mode, problem):
    """
    Get configurations for work-precision plots. These are dictionaries containing strategies and handles and so on.

    Args:
        mode (str): The of the configurations you want to retrieve
        problem (function): A problem to run

    Returns:
        dict: Configurations
    """
    configurations = {}
    if mode == 'regular':
        from pySDC.projects.Resilience.strategies import AdaptivityStrategy, BaseStrategy, IterateStrategy

        handle = 'regular'
        configurations[0] = {
            'handle': handle,
            'strategies': [AdaptivityStrategy(useMPI=True), BaseStrategy(useMPI=True), IterateStrategy(useMPI=True)],
        }
    elif mode == 'step_size_limiting':
        from pySDC.implementations.convergence_controller_classes.step_size_limiter import StepSizeLimiter
        from pySDC.projects.Resilience.strategies import AdaptivityStrategy, ESDIRKStrategy

        limits = [
            25.0,
            50.0,
        ]
        colors = ['teal', 'magenta']
        markers = ['v', 'x']
        markersize = 9
        for i in range(len(limits)):
            configurations[i] = {
                'custom_description': {'convergence_controllers': {StepSizeLimiter: {'dt_max': limits[i]}}},
                'handle': f'steplimiter{limits[i]:.0f}',
                'strategies': [AdaptivityStrategy(useMPI=True)],
                'plotting_params': {
                    'color': colors[i],
                    'marker': markers[i],
                    'label': rf'$\Delta t \leq {{{limits[i]:.0f}}}$',
                    # 'ls': '',
                    'markersize': markersize,
                },
                'num_procs': 1,
            }
        configurations[99] = {
            'custom_description': {},
            'handle': 'no limits',
            'plotting_params': {
                'label': 'no limiter',
                # 'ls': '',
                'markersize': markersize,
            },
            'strategies': [AdaptivityStrategy(useMPI=True)],
            'num_procs': 1,
        }
    elif mode == 'dynamic_restarts':
        """
        Compare Block Gauss-Seidel SDC with restarting the first step in the block or the first step that exceeded the error threshold.
        """
        from pySDC.projects.Resilience.strategies import AdaptivityStrategy, AdaptivityRestartFirstStep

        desc = {}
        desc['sweeper_params'] = {'num_nodes': 3, 'QI': 'IE'}
        desc['step_params'] = {'maxiter': 5}

        ls = {
            1: '-',
            2: '--',
            3: '-.',
            4: ':',
            5: ':',
        }

        configurations[-1] = {
            'strategies': [AdaptivityStrategy(useMPI=True)],
            'num_procs': 1,
        }

        for num_procs in [4, 2]:
            plotting_params = {'ls': ls[num_procs], 'label': f'adaptivity {num_procs} procs'}
            configurations[num_procs] = {
                'strategies': [AdaptivityStrategy(useMPI=True), AdaptivityRestartFirstStep(useMPI=True)],
                'custom_description': desc,
                'num_procs': num_procs,
                'plotting_params': plotting_params,
            }

    elif mode == 'compare_strategies':
        """
        Compare the different SDC strategies.
        """
        from pySDC.projects.Resilience.strategies import (
            AdaptivityStrategy,
            kAdaptivityStrategy,
            AdaptivityPolynomialError,
            BaseStrategy,
        )

        newton_inexactness = False if problem.__name__ in ['run_vdp'] else True

        configurations[1] = {
            'strategies': [AdaptivityPolynomialError(useMPI=True, newton_inexactness=newton_inexactness)],
        }
        configurations[2] = {
            'strategies': [kAdaptivityStrategy(useMPI=True)],
        }
        configurations[0] = {
            'custom_description': {
                'step_params': {'maxiter': 5},
                'sweeper_params': {'num_nodes': 3, 'quad_type': 'RADAU-RIGHT'},
            },
            'strategies': [
                BaseStrategy(useMPI=True),
                AdaptivityStrategy(useMPI=True),
            ],
        }

    elif mode == 'RK_comp':
        """
        Compare parallel adaptive SDC to Runge-Kutta
        """
        from pySDC.projects.Resilience.strategies import (
            AdaptivityStrategy,
            ERKStrategy,
            ESDIRKStrategy,
            ARKStrategy,
            AdaptivityPolynomialError,
            ARK3_CFL_Strategy,
        )

        if problem.__name__ in ['run_Schroedinger', 'run_AC', 'run_RBC', 'run_GS']:
            from pySDC.implementations.sweeper_classes.imex_1st_order_MPI import imex_1st_order_MPI as parallel_sweeper
        else:
            from pySDC.implementations.sweeper_classes.generic_implicit_MPI import (
                generic_implicit_MPI as parallel_sweeper,
            )

        newton_inexactness = False if problem.__name__ in ['run_vdp', 'run_RBC', 'run_GS'] else True

        desc = {}
        desc['sweeper_params'] = {'num_nodes': 3, 'QI': 'IE', 'QE': "EE"}
        desc['step_params'] = {'maxiter': 5}
        num_procs_dt = {
            'run_RBC': 1,
        }.get(problem.__name__, 4)

        desc_poly = {}
        desc_poly['sweeper_class'] = parallel_sweeper
        num_procs_dt_k = 3

        ls = {
            1: '--',
            2: '--',
            3: '-',
            4: '-',
            5: '-',
            12: ':',
        }
        RK_strategies = []
        if problem.__name__ in ['run_Lorenz']:
            RK_strategies.append(ERKStrategy(useMPI=True))
            desc_poly['sweeper_params'] = {'QI': 'MIN-SR-S', 'QE': 'PIC'}
            desc['sweeper_params']['QI'] = 'MIN-SR-S'
            desc['sweeper_params']['QE'] = 'PIC'
        if problem.__name__ in ['run_Schroedinger', 'run_AC', 'run_GS']:
            RK_strategies.append(ARKStrategy(useMPI=True))
        elif problem.__name__ == 'run_RBC':
            RK_strategies.append(ARK3_CFL_Strategy(useMPI=True))
            desc['sweeper_params']['num_nodes'] = 2
            desc['sweeper_params']['QI'] = 'LU'
            desc['sweeper_params']['QE'] = 'PIC'
            desc['step_params']['maxiter'] = 3

            desc_poly['sweeper_params'] = {'num_nodes': 2, 'QI': 'MIN-SR-S'}
            num_procs_dt_k = 2
        else:
            RK_strategies.append(ESDIRKStrategy(useMPI=True))

        configurations[-1] = {
            'strategies': RK_strategies,
            'num_procs': 1,
        }
        if problem.__name__ == 'run_Lorenz':
            configurations[3] = {
                'custom_description': desc_poly,
                'strategies': [AdaptivityPolynomialError(useMPI=True, newton_inexactness=newton_inexactness)],
                'num_procs': 4,
                'num_procs_sweeper': num_procs_dt_k,
                'plotting_params': {
                    'label': rf'$\Delta t$-$k$-adaptivity $N$=4x{num_procs_dt_k}',
                    'ls': ls[num_procs_dt_k * 4],
                },
            }
        else:
            configurations[3] = {
                'custom_description': desc_poly,
                'strategies': [AdaptivityPolynomialError(useMPI=True, newton_inexactness=newton_inexactness)],
                'num_procs': 1,
                'num_procs_sweeper': num_procs_dt_k,
                'plotting_params': {
                    'label': rf'$\Delta t$-$k$-adaptivity $N$=1x{num_procs_dt_k}',
                    'ls': ls[num_procs_dt_k],
                },
            }
        if problem.__name__ in ['run_Lorenz']:
            configurations[2] = {
                'strategies': [AdaptivityStrategy(useMPI=True)],
                'custom_description': {**desc, 'sweeper_class': parallel_sweeper},
                'num_procs': num_procs_dt,
                'num_procs_sweeper': num_procs_dt_k,
                'plotting_params': {
                    'label': rf'$\Delta t$-adaptivity $N$={num_procs_dt}x3',
                    'ls': ls[num_procs_dt * num_procs_dt_k],
                },
            }
        else:
            configurations[2] = {
                'strategies': [AdaptivityStrategy(useMPI=True)],
                'custom_description': desc,
                'num_procs': num_procs_dt,
                'plotting_params': {'label': rf'$\Delta t$-adaptivity $N$={num_procs_dt}x1', 'ls': ls[num_procs_dt]},
            }

    elif mode == 'RK_comp_high_order_RBC':
        """
        Compare parallel adaptive SDC to Runge-Kutta at order five for RBC problem
        """
        from pySDC.projects.Resilience.strategies import (
            AdaptivityStrategy,
            ERKStrategy,
            ESDIRKStrategy,
            ARKStrategy,
            AdaptivityPolynomialError,
            ARK3_CFL_Strategy,
        )

        assert problem.__name__ == 'run_RBC'

        from pySDC.implementations.sweeper_classes.imex_1st_order_MPI import imex_1st_order_MPI as parallel_sweeper

        newton_inexactness = False

        desc = {}
        desc['sweeper_params'] = {'num_nodes': 3, 'QI': 'IE', 'QE': "EE"}
        desc['step_params'] = {'maxiter': 5}
        num_procs_dt = 1

        desc_poly = {}
        desc_poly['sweeper_class'] = parallel_sweeper
        num_procs_dt_k = 3

        ls = {
            1: '--',
            2: '--',
            3: '-',
            4: '-',
            5: '-',
            12: ':',
        }
        RK_strategies = [ARK3_CFL_Strategy(useMPI=True)]
        desc['sweeper_params']['num_nodes'] = 3
        desc['sweeper_params']['QI'] = 'LU'
        desc['sweeper_params']['QE'] = 'PIC'
        desc['step_params']['maxiter'] = 5

        desc_poly['sweeper_params'] = {'num_nodes': 3, 'QI': 'MIN-SR-S'}
        num_procs_dt_k = 3

        configurations[-1] = {
            'strategies': RK_strategies,
            'num_procs': 1,
        }
        configurations[3] = {
            'custom_description': desc_poly,
            'strategies': [AdaptivityPolynomialError(useMPI=True, newton_inexactness=newton_inexactness)],
            'num_procs': 1,
            'num_procs_sweeper': num_procs_dt_k,
            'plotting_params': {
                'label': rf'$\Delta t$-$k$-adaptivity $N$=1x{num_procs_dt_k}',
                'ls': ls[num_procs_dt_k],
            },
        }
        configurations[2] = {
            'strategies': [AdaptivityStrategy(useMPI=True)],
            'custom_description': desc,
            'num_procs': num_procs_dt,
            'plotting_params': {'label': rf'$\Delta t$-adaptivity $N$={num_procs_dt}x1', 'ls': ls[num_procs_dt]},
        }

    elif mode == 'parallel_efficiency':
        """
        Compare parallel runs of the step size adaptive SDC
        """
        from pySDC.projects.Resilience.strategies import AdaptivityStrategy, AdaptivityPolynomialError

        if problem.__name__ in ['run_Schroedinger', 'run_AC', 'run_GS', 'run_RBC']:
            from pySDC.implementations.sweeper_classes.imex_1st_order_MPI import imex_1st_order_MPI as parallel_sweeper
        else:
            from pySDC.implementations.sweeper_classes.generic_implicit_MPI import (
                generic_implicit_MPI as parallel_sweeper,
            )

        desc = {}
        desc['sweeper_params'] = {'num_nodes': 3, 'QI': 'IE', 'QE': 'EE'}
        desc['step_params'] = {'maxiter': 5}

        if problem.__name__ in ['run_RBC']:
            desc['sweeper_params']['QE'] = 'PIC'
            desc['sweeper_params']['QI'] = 'LU'

        ls = {
            1: '-',
            2: '--',
            3: '-.',
            4: '--',
            5: ':',
            12: ':',
        }

        newton_inexactness = False if problem.__name__ in ['run_vdp'] else True

        for num_procs in [4, 1]:
            plotting_params = (
                {'ls': ls[num_procs], 'label': fr'$\Delta t$-adaptivity $N$={num_procs}x1'} if num_procs > 1 else {}
            )
            configurations[num_procs] = {
                'strategies': [AdaptivityStrategy(useMPI=True)],
                'custom_description': desc.copy(),
                'num_procs': num_procs,
                'plotting_params': plotting_params.copy(),
            }
            configurations[num_procs * 100 + 79] = {
                'custom_description': {'sweeper_class': parallel_sweeper},
                'strategies': [
                    AdaptivityPolynomialError(
                        useMPI=True, newton_inexactness=newton_inexactness, linear_inexactness=True
                    )
                ],
                'num_procs_sweeper': 3,
                'num_procs': num_procs,
                'plotting_params': {
                    'ls': ls.get(num_procs * 3, '-'),
                    'label': rf'$\Delta t$-$k$-adaptivity $N$={num_procs}x3',
                },
            }

        configurations[200 + 79] = {
            'strategies': [
                AdaptivityPolynomialError(useMPI=True, newton_inexactness=newton_inexactness, linear_inexactness=True)
            ],
            'num_procs': 1,
        }
    elif mode == 'parallel_efficiency_dt':
        """
        Compare parallel runs of the step size adaptive SDC
        """
        from pySDC.projects.Resilience.strategies import AdaptivityStrategy

        if problem.__name__ in ['run_Schroedinger', 'run_AC', 'run_GS', 'run_RBC']:
            from pySDC.implementations.sweeper_classes.imex_1st_order_MPI import imex_1st_order_MPI as parallel_sweeper
        else:
            from pySDC.implementations.sweeper_classes.generic_implicit_MPI import (
                generic_implicit_MPI as parallel_sweeper,
            )

        desc = {}
        desc['sweeper_params'] = {'num_nodes': 3, 'QI': 'IE', 'QE': 'EE'}
        desc['step_params'] = {'maxiter': 5}

        if problem.__name__ in ['run_RBC']:
            desc['sweeper_params']['QE'] = 'PIC'
            desc['sweeper_params']['QI'] = 'LU'

        desc_serial = {
            'step_params': {'maxiter': 5},
            'sweeper_params': {'num_nodes': 3, 'quad_type': 'RADAU-RIGHT'},
        }

        ls = {
            1: '-',
            2: '--',
            3: '-.',
            4: '--',
            5: ':',
            12: ':',
        }

        newton_inexactness = False if problem.__name__ in ['run_vdp'] else True

        for num_procs in [4, 1]:
            configurations[num_procs] = {
                'strategies': [AdaptivityStrategy(useMPI=True)],
                'custom_description': desc.copy() if num_procs > 1 else desc_serial,
                'num_procs': num_procs,
                'plotting_params': {
                    'ls': ls.get(num_procs, '-'),
                    'label': rf'$\Delta t$-adaptivity $N$={num_procs}x1',
                },
            }
            configurations[num_procs * 200 + 79] = {
                'custom_description': {
                    'sweeper_class': parallel_sweeper,
                    'sweeper_params': {'QI': 'MIN-SR-S', 'QE': 'PIC'},
                    'step_params': {'maxiter': 5},
                },
                'strategies': [AdaptivityStrategy(useMPI=True)],
                'num_procs_sweeper': 3,
                'num_procs': num_procs,
                'plotting_params': {
                    'ls': ls.get(num_procs * 3, '-'),
                    'label': rf'$\Delta t$-adaptivity $N$={num_procs}x3',
                },
            }
    elif mode == 'parallel_efficiency_dt_k':
        """
        Compare parallel runs of the step size adaptive SDC
        """
        from pySDC.projects.Resilience.strategies import AdaptivityPolynomialError

        if problem.__name__ in ['run_Schroedinger', 'run_AC', 'run_GS', 'run_RBC']:
            from pySDC.implementations.sweeper_classes.imex_1st_order_MPI import imex_1st_order_MPI as parallel_sweeper
        else:
            from pySDC.implementations.sweeper_classes.generic_implicit_MPI import (
                generic_implicit_MPI as parallel_sweeper,
            )

        ls = {
            1: '-',
            2: '--',
            3: '-.',
            4: '--',
            5: ':',
            12: ':',
        }

        QI = {
            (1, 3, 'run_Lorenz'): 'MIN-SR-NS',
            (1, 1, 'run_Lorenz'): 'MIN-SR-NS',
            (4, 1, 'run_Lorenz'): 'IE',
        }

        newton_inexactness = False if problem.__name__ in ['run_vdp'] else True

        for num_procs in [4, 1]:
            configurations[num_procs * 100 + 79] = {
                'custom_description': {
                    'sweeper_class': parallel_sweeper,
                    'sweeper_params': {'QI': QI.get((num_procs, 3, problem.__name__), 'MIN-SR-S'), 'QE': 'PIC'},
                },
                'strategies': [
                    AdaptivityPolynomialError(
                        useMPI=True, newton_inexactness=newton_inexactness, linear_inexactness=True
                    )
                ],
                'num_procs_sweeper': 3,
                'num_procs': num_procs,
                'plotting_params': {
                    'ls': ls.get(num_procs * 3, '-'),
                    'label': rf'$\Delta t$-$k$-adaptivity $N$={num_procs}x3',
                },
            }
            configurations[num_procs * 200 + 79] = {
                'custom_description': {
                    'sweeper_params': {'QI': QI.get((num_procs, 1, problem.__name__), 'MIN-SR-S'), 'QE': 'PIC'},
                },
                'strategies': [
                    AdaptivityPolynomialError(
                        useMPI=True, newton_inexactness=newton_inexactness, linear_inexactness=True
                    )
                ],
                'num_procs_sweeper': 1,
                'num_procs': num_procs,
                'plotting_params': {
                    'ls': ls.get(num_procs, '-'),
                    'label': rf'$\Delta t$-$k$-adaptivity $N$={num_procs}x1',
                },
            }
    elif mode == 'interpolate_between_restarts':
        """
        Compare adaptivity with interpolation between restarts and without
        """
        from pySDC.projects.Resilience.strategies import AdaptivityPolynomialError

        i = 0
        for interpolate_between_restarts, handle, ls in zip(
            [True, False], ['Interpolation between restarts', 'regular'], ['--', '-']
        ):
            configurations[i] = {
                'strategies': [
                    AdaptivityPolynomialError(interpolate_between_restarts=interpolate_between_restarts, useMPI=True)
                ],
                'plotting_params': {'ls': ls},
                'handle': handle,
            }
            i += 1
    elif mode == 'diagonal_SDC':
        """
        Run diagonal SDC with different number of nodes and ranks. You can use this to compute a speedup, but it's not strong scaling!
        """
        from pySDC.projects.Resilience.strategies import AdaptivityPolynomialError

        if problem.__name__ in ['run_Schroedinger']:
            from pySDC.implementations.sweeper_classes.imex_1st_order_MPI import imex_1st_order_MPI as parallel_sweeper
        else:
            from pySDC.implementations.sweeper_classes.generic_implicit_MPI import (
                generic_implicit_MPI as parallel_sweeper,
            )

        for parallel in [False, True]:
            desc = {'sweeper_class': parallel_sweeper} if parallel else {}
            for num_nodes, ls in zip([3, 4, 2], ['-', '--', ':', '-.']):
                configurations[num_nodes + (99 if parallel else 0)] = {
                    'custom_description': {**desc, 'sweeper_params': {'num_nodes': num_nodes}},
                    'strategies': [
                        AdaptivityPolynomialError(useMPI=True, newton_inexactness=True, linear_inexactness=True)
                    ],
                    'num_procs_sweeper': num_nodes if parallel else 1,
                    'num_procs': 1,
                    'handle': f'{num_nodes} nodes',
                    'plotting_params': {
                        'ls': ls,
                        'label': f'{num_nodes} procs',
                        # **{'color': 'grey' if parallel else None},
                    },
                }

    elif mode[:13] == 'vdp_stiffness':
        """
        Run van der Pol with different parameter for the nonlinear term, which controls the stiffness.
        """
        from pySDC.projects.Resilience.strategies import (
            AdaptivityStrategy,
            ERKStrategy,
            ESDIRKStrategy,
            AdaptivityPolynomialError,
        )
        from pySDC.implementations.sweeper_classes.generic_implicit_MPI import (
            generic_implicit_MPI as parallel_sweeper,
        )

        Tends = {
            1000: 2000,
            100: 200,
            10: 20,
            0: 2,
        }
        mu = float(mode[14:])
        Tend = Tends[mu]

        problem_desc = {'problem_params': {'mu': mu}}

        desc = {}
        desc['sweeper_params'] = {'num_nodes': 3, 'QI': 'IE'}
        desc['step_params'] = {'maxiter': 5}
        desc['problem_params'] = problem_desc['problem_params']

        ls = {
            1: '-',
            2: '--',
            3: '-.',
            4: ':',
            5: ':',
            'MIN-SR-S': '-',
            'MIN-SR-NS': '--',
            'MIN-SR-FLEX': '-.',
        }

        if mu < 100:
            configurations[2] = {
                'strategies': [ERKStrategy(useMPI=True)],
                'num_procs': 1,
                'handle': mode,
                'plotting_params': {'label': 'CP5(4)'},
                'custom_description': problem_desc,
                'Tend': Tend,
            }
        configurations[1] = {
            'strategies': [AdaptivityStrategy(useMPI=True)],
            'custom_description': desc,
            'num_procs': 4,
            'plotting_params': {'ls': ls[1], 'label': 'SDC $N$=4x1'},
            'handle': mode,
            'Tend': Tend,
        }
        configurations[4] = {
            'strategies': [ESDIRKStrategy(useMPI=True)],
            'num_procs': 1,
            'handle': mode,
            'plotting_params': {'label': 'ESDIRK5(3)'},
            'custom_description': problem_desc,
            'Tend': Tend,
        }
        for QI, i in zip(
            [
                'MIN-SR-S',
                # 'MIN-SR-FLEX',
            ],
            [9991, 12123127391, 1231723109247102731092],
        ):
            configurations[i] = {
                'custom_description': {
                    'sweeper_params': {'num_nodes': 3, 'QI': QI},
                    'problem_params': desc["problem_params"],
                    'sweeper_class': parallel_sweeper,
                },
                'strategies': [
                    AdaptivityPolynomialError(
                        useMPI=True, newton_inexactness=False, linear_inexactness=False, max_slope=4
                    )
                ],
                'num_procs_sweeper': 3,
                'num_procs': 1,
                'plotting_params': {
                    'ls': ls.get(QI, '-'),
                    'label': rf'$\Delta t$-$k$-adaptivity $N$={1}x3',
                },
                'handle': f'{mode}-{QI}',
                'Tend': Tend,
            }

    elif mode == 'inexactness':
        """
        Compare inexact SDC to exact SDC
        """
        from pySDC.projects.Resilience.strategies import (
            AdaptivityPolynomialError,
        )

        if problem.__name__ in ['run_Schroedinger']:
            from pySDC.implementations.sweeper_classes.imex_1st_order_MPI import imex_1st_order_MPI as parallel_sweeper
        else:
            from pySDC.implementations.sweeper_classes.generic_implicit_MPI import (
                generic_implicit_MPI as parallel_sweeper,
            )

        strategies = [
            AdaptivityPolynomialError,
        ]

        inexactness = {
            'newton_inexactness': True,
            'linear_inexactness': True,
        }
        no_inexactness = {
            'newton_inexactness': False,
            'linear_inexactness': False,
            'SDC_maxiter': 99,
            'use_restol_rel': False,
        }

        configurations[1] = {
            'custom_description': {'sweeper_class': parallel_sweeper},
            'strategies': [me(useMPI=True, **no_inexactness) for me in strategies],
            'num_procs_sweeper': 3,
            'handle': 'exact',
            'plotting_params': {'ls': '--'},
        }
        configurations[0] = {
            'custom_description': {'sweeper_class': parallel_sweeper},
            'strategies': [me(useMPI=True, **inexactness) for me in strategies],
            'handle': 'inexact',
            'num_procs_sweeper': 3,
        }
    elif mode == 'compare_adaptivity':
        """
        Compare various modes of adaptivity
        """
        # TODO: configurations not final!
        from pySDC.projects.Resilience.strategies import (
            # AdaptivityCollocationTypeStrategy,
            # AdaptivityCollocationRefinementStrategy,
            AdaptivityStrategy,
            # AdaptivityExtrapolationWithinQStrategy,
            ESDIRKStrategy,
            ARKStrategy,
            AdaptivityPolynomialError,
        )

        if problem.__name__ in ['run_Schroedinger']:
            from pySDC.implementations.sweeper_classes.imex_1st_order_MPI import imex_1st_order_MPI as parallel_sweeper
        else:
            from pySDC.implementations.sweeper_classes.generic_implicit_MPI import (
                generic_implicit_MPI as parallel_sweeper,
            )

        inexactness_params = {
            # 'double_adaptivity': True,
            'newton_inexactness': True,
            'linear_inexactness': True,
        }

        strategies = [
            AdaptivityPolynomialError,
            # AdaptivityCollocationTypeStrategy,
            # AdaptivityExtrapolationWithinQStrategy,
        ]

        # restol = None
        # for strategy in strategies:
        #     strategy.restol = restol

        configurations[1] = {
            'custom_description': {'sweeper_class': parallel_sweeper},
            'strategies': [me(useMPI=True, **inexactness_params) for me in strategies],
            'handle': 'parallel',
            'num_procs_sweeper': 3,
            'plotting_params': {'ls': '-', 'label': '3 procs'},
        }
        configurations[2] = {
            'strategies': [me(useMPI=True, **inexactness_params) for me in strategies],
            'plotting_params': {'ls': '--'},
        }
        configurations[4] = {
            'custom_description': {'step_params': {'maxiter': 5}},
            'strategies': [AdaptivityStrategy(useMPI=True)],
        }

        desc_RK = {}
        configurations[-1] = {
            'strategies': [
                ARKStrategy(useMPI=True) if problem.__name__ == 'run_Schroedinger' else ESDIRKStrategy(useMPI=True),
            ],
            'num_procs': 1,
            'custom_description': desc_RK,
        }

    elif mode == 'preconditioners':
        """
        Compare different preconditioners
        """
        from pySDC.projects.Resilience.strategies import (
            AdaptivityStrategy,
            IterateStrategy,
            BaseStrategy,
            ESDIRKStrategy,
            ERKStrategy,
            AdaptivityPolynomialError,
        )

        inexacness = True
        strategies = [
            AdaptivityPolynomialError(
                useMPI=True, SDC_maxiter=29, newton_inexactness=inexacness, linear_inexactness=inexacness
            ),
            BaseStrategy(useMPI=True),
        ]

        desc = {}
        desc['sweeper_params'] = {
            'num_nodes': 3,
        }
        # desc['step_params'] = {'maxiter': 5}

        precons = ['IE', 'LU']
        ls = ['-.', '--', '-', ':']
        for i in range(len(precons) + 1):
            if i < len(precons):
                desc['sweeper_params']['QI'] = precons[i]
                handle = precons[i]
            else:
                handle = None
            configurations[i] = {
                'strategies': strategies,
                'custom_description': copy.deepcopy(desc),
                'handle': handle,
                'plotting_params': {'ls': ls[i]},
            }
    elif mode == 'RK_comp_high_order':
        """
        Compare higher order SDC than we can get with RKM to RKM
        """
        from pySDC.projects.Resilience.strategies import (
            AdaptivityStrategy,
            ERKStrategy,
            ESDIRKStrategy,
            ARKStrategy,
            AdaptivityPolynomialError,
        )

        if problem.__name__ in ['run_Schroedinger']:
            from pySDC.implementations.sweeper_classes.imex_1st_order_MPI import imex_1st_order_MPI as parallel_sweeper
        else:
            from pySDC.implementations.sweeper_classes.generic_implicit_MPI import (
                generic_implicit_MPI as parallel_sweeper,
            )

        desc = {}
        desc['sweeper_params'] = {'num_nodes': 4, 'QI': 'IE', 'QE': "EE"}
        desc['step_params'] = {'maxiter': 7}

        desc_poly = {}
        desc_poly['sweeper_class'] = parallel_sweeper
        desc_poly['sweeper_params'] = {'num_nodes': 4}

        ls = {
            1: '-',
            2: '--',
            3: '-.',
            4: ':',
            5: ':',
        }

        desc_RK = {}
        if problem.__name__ in ['run_Schroedinger']:
            desc_RK['problem_params'] = {'imex': True}

        configurations[3] = {
            'custom_description': desc_poly,
            'strategies': [AdaptivityPolynomialError(useMPI=True)],
            'num_procs': 1,
            'num_procs_sweeper': 4,
        }
        configurations[-1] = {
            'strategies': [
                ERKStrategy(useMPI=True),
                ARKStrategy(useMPI=True) if problem.__name__ in ['run_Schroedinger'] else ESDIRKStrategy(useMPI=True),
            ],
            'num_procs': 1,
            'custom_description': desc_RK,
        }

        configurations[2] = {
            'strategies': [AdaptivityStrategy(useMPI=True)],
            'custom_description': desc,
            'num_procs': 4,
        }
    elif mode == 'avoid_restarts':
        """
        Test how well avoiding restarts works.
        """
        from pySDC.projects.Resilience.strategies import (
            AdaptivityStrategy,
            AdaptivityAvoidRestartsStrategy,
            AdaptivityPolynomialStrategy,
        )

        desc = {'sweeper_params': {'QI': 'IE'}, 'step_params': {'maxiter': 3}}
        param_range = [1e-3, 1e-5]
        configurations[0] = {
            'strategies': [AdaptivityPolynomialStrategy(useMPI=True)],
            'plotting_params': {'ls': '--'},
            'custom_description': desc,
            'param_range': param_range,
        }
        configurations[1] = {
            'strategies': [AdaptivityAvoidRestartsStrategy(useMPI=True)],
            'plotting_params': {'ls': '-.'},
            'custom_description': desc,
            'param_range': param_range,
        }
        configurations[2] = {
            'strategies': [AdaptivityStrategy(useMPI=True)],
            'custom_description': desc,
            'param_range': param_range,
        }
    else:
        raise NotImplementedError(f'Don\'t know the mode "{mode}"!')

    return configurations


def get_fig(x=1, y=1, target='adaptivity', **kwargs):  # pragma: no cover
    """
    Get a figure to plot in.

    Args:
        x (int): How many panels in horizontal direction you want
        y (int): How many panels in vertical direction you want
        target (str): Where the plot is supposed to end up

    Returns:
        matplotlib.pyplot.Figure
    """
    width = 1.0
    ratio = 1.0 if y == 2 else 0.5
    if target == 'adaptivity':
        journal = 'Springer_Numerical_Algorithms'
    elif target == 'thesis':
        journal = 'TUHH_thesis'
    elif target == 'talk':
        journal = 'JSC_beamer'
    else:
        raise NotImplementedError

    keyword_arguments = {
        'figsize': figsize_by_journal(journal, width, ratio),
        'layout': 'constrained',
        **kwargs,
    }
    return plt.subplots(y, x, **keyword_arguments)


def save_fig(
    fig, name, work_key, precision_key, legend=True, format='pdf', base_path='data', squares=True, ncols=None, **kwargs
):  # pragma: no cover
    """
    Save a figure with a legend on the bottom.

    Args:
        fig (matplotlib.pyplot.Figure): Figure you want to save
        name (str): Name of the plot to put in the path
        work_key (str): The key in the recorded data you want on the x-axis
        precision_key (str): The key in the recorded data you want on the y-axis
        legend (bool): Put a legend or not
        format (str): Format to store the figure with
        base_path (str): Some path where all the files are stored
        squares (bool): Adjust aspect ratio to squares if true

    Returns:
        None
    """
    handles = []
    labels = []
    for ax in fig.get_axes():
        h, l = ax.get_legend_handles_labels()
        handles += [h[i] for i in range(len(h)) if l[i] not in labels]
        labels += [me for me in l if me not in labels]
        if squares:
            ax.set_box_aspect(1)
    # order = np.argsort([me[0] for me in labels])
    order = np.arange(len(labels))
    fig.legend(
        [handles[i] for i in order],
        [labels[i] for i in order],
        loc='outside lower center',
        ncols=ncols if ncols else 3 if len(handles) % 3 == 0 else 4,
        frameon=False,
        fancybox=True,
        handlelength=2.2,
    )

    path = f'{base_path}/wp-{name}-{work_key}-{precision_key}.{format}'
    fig.savefig(path, bbox_inches='tight', **kwargs)
    print(f'Stored figure \"{path}\"')


def all_problems(
    mode='compare_strategies', plotting=True, base_path='data', target='adaptivity', **kwargs
):  # pragma: no cover
    """
    Make a plot comparing various strategies for all problems.

    Args:
        work_key (str): The key in the recorded data you want on the x-axis
        precision_key (str): The key in the recorded data you want on the y-axis

    Returns:
        None
    """

    if target == 'talk':
        fig, axs = get_fig(4, 1, target=target)
    else:
        fig, axs = get_fig(2, 2, target=target)

    shared_params = {
        'work_key': 'k_SDC',
        'precision_key': 'e_global',
        'num_procs': 1,
        'runs': 1,
        'comm_world': MPI.COMM_WORLD,
        'record': False,
        'plotting': plotting,
        **kwargs,
    }

    if target == 'adaptivity':
        problems = [run_vdp, run_quench, run_Schroedinger, run_AC]
    elif target in ['thesis', 'talk']:
        problems = [run_vdp, run_Lorenz, run_GS, run_RBC]
    else:
        raise NotImplementedError

    logger.log(26, f"Doing for all problems {mode}")
    for i in range(len(problems)):
        execute_configurations(
            **shared_params,
            problem=problems[i],
            ax=axs.flatten()[i],
            decorate=True,
            configurations=get_configs(mode, problems[i]),
            mode=mode,
        )

    if plotting and shared_params['comm_world'].rank == 0:
        ncols = {
            'parallel_efficiency': 2,
            'parallel_efficiency_dt': 2,
            'parallel_efficiency_dt_k': 2,
            'RK_comp': 2,
        }
        if target == 'talk':
            _ncols = 4
        else:
            _ncols = ncols.get(mode, None)

        if shared_params['work_key'] == 'param':
            for ax, prob in zip(fig.get_axes(), problems):
                add_param_order_lines(ax, prob)
        save_fig(
            fig=fig,
            name=mode,
            work_key=shared_params['work_key'],
            precision_key=shared_params['precision_key'],
            legend=True,
            base_path=base_path,
            ncols=_ncols,
        )


def add_param_order_lines(ax, problem):
    if problem.__name__ == 'run_vdp':
        yRfixed = 1e18
        yRdt = 1e-1
        yRdtk = 1e-4
    elif problem.__name__ == 'run_quench':
        yRfixed = 4e1
        yRdt = 1e4
        yRdtk = 1e4
    elif problem.__name__ == 'run_Schroedinger':
        yRfixed = 5
        yRdt = 1
        yRdtk = 1e-2
    elif problem.__name__ == 'run_AC':
        yRfixed = 1e8
        yRdt = 2e-2
        yRdtk = 1e-3
    elif problem.__name__ == 'run_Lorenz':
        yRfixed = 1e1
        yRdt = 2e-2
        yRdtk = 7e-4
    elif problem.__name__ == 'run_RBC':
        yRfixed = 1e-6
        yRdt = 4e-5
        yRdtk = 8e-6
    elif problem.__name__ == 'run_GS':
        yRfixed = 4e-3
        yRdt = 5e0
        yRdtk = 8e-1
    else:
        return None
    add_order_line(ax, 1, '--', yRdt, marker=None)
    add_order_line(ax, 5 / 4, ':', yRdtk, marker=None)
    add_order_line(ax, 5, '-.', yRfixed, marker=None)


def ODEs(mode='compare_strategies', plotting=True, base_path='data', **kwargs):  # pragma: no cover
    """
    Make a plot comparing various strategies for the two ODEs.

    Args:
        work_key (str): The key in the recorded data you want on the x-axis
        precision_key (str): The key in the recorded data you want on the y-axis

    Returns:
        None
    """

    fig, axs = get_fig(x=2, y=1)

    shared_params = {
        'work_key': 'k_SDC',
        'precision_key': 'e_global',
        'num_procs': 1,
        'runs': 1,
        'comm_world': MPI.COMM_WORLD,
        'record': False,
        'plotting': plotting,
        **kwargs,
    }

    problems = [run_vdp, run_Lorenz]

    for i in range(len(problems)):
        execute_configurations(
            **shared_params,
            problem=problems[i],
            ax=axs.flatten()[i],
            decorate=i == 0,
            configurations=get_configs(mode, problems[i]),
        )

    if plotting and shared_params['comm_world'].rank == 0:
        save_fig(
            fig=fig,
            name=f'ODEs-{mode}',
            work_key=shared_params['work_key'],
            precision_key=shared_params['precision_key'],
            legend=True,
            base_path=base_path,
        )


def single_problem(mode, problem, plotting=True, base_path='data', target='thesis', **kwargs):  # pragma: no cover
    """
    Make a plot for a single problem

    Args:
        mode (str): What you want to look at
        problem (function): A problem to run
    """
    if target == 'thesis':
        fig, ax = get_fig(1, 1, figsize=figsize_by_journal('TUHH_thesis', 0.7, 0.6))
    else:
        fig, ax = get_fig(1, 1, figsize=figsize_by_journal('Springer_Numerical_Algorithms', 1, 0.8))

    params = {
        'work_key': 'k_SDC',
        'precision_key': 'e_global',
        'num_procs': 1,
        'runs': 1,
        'comm_world': MPI.COMM_WORLD,
        'record': False,
        'plotting': plotting,
        **kwargs,
    }

    logger.log(26, f"Doing single problem {mode}")
    execute_configurations(
        **params, problem=problem, ax=ax, decorate=True, configurations=get_configs(mode, problem), mode=mode
    )

    if plotting:
        save_fig(
            fig=fig,
            name=f'{problem.__name__}-{mode}',
            work_key=params['work_key'],
            precision_key=params['precision_key'],
            legend=False,
            base_path=base_path,
            squares=target != 'thesis',
        )


def vdp_stiffness_plot(base_path='data', format='pdf', **kwargs):  # pragma: no cover
    fig, axs = get_fig(3, 1, sharex=False, sharey=False)

    mus = [10, 100, 1000]

    for i in range(len(mus)):
        params = {
            'runs': 1,
            'problem': run_vdp,
            'record': False,
            'work_key': 't',
            'precision_key': 'e_global',
            'comm_world': MPI.COMM_WORLD,
            **kwargs,
        }
        params['num_procs'] = min(params['comm_world'].size, 5)
        params['plotting'] = params['comm_world'].rank == 0

        mode = f'vdp_stiffness-{mus[i]}'
        configurations = get_configs(mode=mode, problem=run_vdp)
        execute_configurations(**params, ax=axs.flatten()[i], decorate=True, configurations=configurations, mode=mode)
        axs.flatten()[i].set_title(rf'$\mu={{{mus[i]}}}$')

    fig.suptitle('Van der Pol')
    if params['comm_world'].rank == 0:
        save_fig(
            fig=fig,
            name='vdp-stiffness',
            work_key=params['work_key'],
            precision_key=params['precision_key'],
            legend=False,
            base_path=base_path,
            format=format,
        )


def add_order_line(ax, order, ls, y_right=1.0, marker='.'):
    x_min = min([min(line.get_xdata()) for line in ax.get_lines()])
    x_max = max([max(line.get_xdata()) for line in ax.get_lines()])
    y_min = min([min(line.get_ydata()) for line in ax.get_lines()])
    y_max = max([max(line.get_ydata()) for line in ax.get_lines()])
    x = np.logspace(np.log10(x_min), np.log10(x_max), 100)
    y = y_right * (x / x_max) ** order
    mask = np.logical_and(y > y_min, y < y_max)
    ax.loglog(x[mask], y[mask], ls=ls, color='black', label=f'Order {order}', marker=marker, markevery=5)


def aggregate_parallel_efficiency_plot():  # pragma: no cover
    """
    Make a "weak scaling" plot for diagonal SDC
    """
    from pySDC.projects.Resilience.strategies import AdaptivityPolynomialError

    fig, axs = plt.subplots(2, 2)

    _fig, _ax = plt.subplots(1, 1)
    num_procs = 1
    num_procs_sweeper = 2
    problem = run_quench

    num_procs_sweeper_list = [2, 3, 4]

    for problem, ax in zip([run_vdp, run_Lorenz, run_quench], axs.flatten()):
        speedup = []
        for num_procs_sweeper in num_procs_sweeper_list:
            s, e = plot_parallel_efficiency_diagonalSDC(
                ax=_ax,
                work_key='t',
                precision_key='e_global_rel',
                num_procs=num_procs,
                num_procs_sweeper=num_procs_sweeper,
                problem=problem,
                strategy=AdaptivityPolynomialError(),
                mode='diagonal_SDC',
                handle=f'{num_procs_sweeper} nodes',
            )
            speedup += [s]
            decorate_panel(ax, problem, work_key='nprocs', precision_key='')

        ax.plot(num_procs_sweeper_list, speedup, label='speedup')
        ax.plot(
            num_procs_sweeper_list,
            [speedup[i] / num_procs_sweeper_list[i] for i in range(len(speedup))],
            label='parallel efficiency',
        )

    fig.tight_layout()
    save_fig(fig, 'parallel_efficiency', 'nprocs', 'speedup')


if __name__ == "__main__":
    comm_world = MPI.COMM_WORLD

    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument('--mode', type=str, default='compare_strategies')
    parser.add_argument('--record', type=str, choices=['True', 'False'], default='True')
    parser.add_argument('--plotting', type=str, choices=['True', 'False'], default='True')
    parser.add_argument('--runs', type=int, default=5)
    parser.add_argument(
        '--problem', type=str, choices=['vdp', 'RBC', 'AC', 'quench', 'Lorenz', 'Schroedinger', 'GS'], default='vdp'
    )
    parser.add_argument('--work_key', type=str, default='t')
    parser.add_argument('--precision_key', type=str, default='e_global_rel')
    parser.add_argument('--logger_level', type=int, default='25')

    args = parser.parse_args()

    problems = {
        'Lorenz': run_Lorenz,
        'vdp': run_vdp,
        'Schroedinger': run_Schroedinger,
        'quench': run_quench,
        'AC': run_AC,
        'RBC': run_RBC,
        'GS': run_GS,
    }

    params = {
        **vars(args),
        'record': args.record == 'True',
        'plotting': args.plotting == 'True' and comm_world.rank == 0,
        'problem': problems[args.problem],
    }

    LOGGER_LEVEL = params.pop('logger_level')

    single_problem(**params)

    if comm_world.rank == 0:
        plt.show()
