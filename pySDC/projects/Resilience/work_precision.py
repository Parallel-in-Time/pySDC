from mpi4py import MPI
import numpy as np
import matplotlib.pyplot as plt
import pickle
import logging
from time import perf_counter
import copy

from pySDC.projects.Resilience.strategies import merge_descriptions
from pySDC.projects.Resilience.Lorenz import run_Lorenz
from pySDC.projects.Resilience.vdp import run_vdp
from pySDC.projects.Resilience.Schroedinger import run_Schroedinger
from pySDC.projects.Resilience.quench import run_quench
from pySDC.projects.Resilience.AC import run_AC

from pySDC.helpers.stats_helper import get_sorted, filter_stats
from pySDC.helpers.plot_helper import setup_mpl, figsize_by_journal

setup_mpl(reset=True)
LOGGER_LEVEL = 25
LOG_TO_FILE = False

logging.getLogger('matplotlib.texmanager').setLevel(90)

MAPPINGS = {
    'e_global': ('e_global_post_run', max, False),
    'e_global_rel': ('e_global_rel_post_run', max, False),
    't': ('timing_run', max, False),
    # 'e_local_max': ('e_local_post_step', max, False),
    'k_SDC': ('k', sum, None),
    'k_SDC_no_restart': ('k', sum, False),
    'k_Newton': ('work_newton', sum, None),
    'k_linear': ('work_linear', sum, None),
    'k_Newton_no_restart': ('work_newton', sum, False),
    'k_rhs': ('work_rhs', sum, None),
    'num_steps': ('dt', len, None),
    'restart': ('restart', sum, None),
    'dt_mean': ('dt', np.mean, False),
    'dt_max': ('dt', max, False),
    'dt_min': ('dt', min, False),
    'dt_sigma': ('dt', np.std, False),
    'e_embedded_max': ('error_embedded_estimate', max, False),
    'u0_increment_max': ('u0_increment', max, None),
    'u0_increment_mean': ('u0_increment', np.mean, None),
    'u0_increment_max_no_restart': ('u0_increment', max, False),
    'u0_increment_mean_no_restart': ('u0_increment', np.mean, False),
}

logger = logging.getLogger('WorkPrecision')
logger.setLevel(LOGGER_LEVEL)


def get_forbidden_combinations(problem, strategy, **kwargs):
    """
    Check if the combination of strategy and problem is forbidden

    Args:
        problem (function): A problem to run
        strategy (Strategy): SDC strategy
    """
    if strategy.name == 'ERK':
        if problem.__name__ in ['run_quench', 'run_Schroedinger', 'run_AC']:
            return True

    return False


def single_run(
    problem,
    strategy,
    data,
    custom_description,
    num_procs=1,
    comm_world=None,
    problem_args=None,
    hooks=None,
    Tend=None,
    num_procs_sweeper=1,
):
    """
    Make a single run of a particular problem with a certain strategy.

    Args:
        problem (function): A problem to run
        strategy (Strategy): SDC strategy
        data (dict): Put the results in here
        custom_description (dict): Overwrite presets
        num_procs (int): Number of processes for the time communicator
        comm_world (mpi4py.MPI.Intracomm): Communicator that is available for the entire script
        hooks (list): List of additional hooks
        num_procs_sweeper (int): Number of processes for the sweeper

    Returns:
        dict: Stats generated by the run
    """
    from pySDC.implementations.hooks.log_errors import LogGlobalErrorPostRun
    from pySDC.implementations.hooks.log_work import LogWork
    from pySDC.projects.Resilience.hook import LogData

    hooks = hooks if hooks else []

    t_last = perf_counter()

    num_procs_tot = num_procs * num_procs_sweeper
    comm = comm_world.Split(comm_world.rank < num_procs_tot)
    if comm_world.rank >= num_procs_tot:
        comm.Free()
        return None

    # make communicators for time and sweepers
    comm_time = comm.Split(comm.rank // num_procs)
    comm_sweep = comm.Split(comm_time.rank)

    strategy_description = strategy.get_custom_description(problem, num_procs)
    description = merge_descriptions(strategy_description, custom_description)
    if comm_sweep.size > 1:
        description['sweeper_params']['comm'] = comm_sweep

    controller_params = {
        'logger_level': LOGGER_LEVEL,
        'log_to_file': LOG_TO_FILE,
        'fname': 'out.txt',
        **strategy.get_controller_params(),
    }
    problem_args = {} if problem_args is None else problem_args

    stats, controller, crash = problem(
        custom_description=description,
        Tend=strategy.get_Tend(problem, num_procs) if Tend is None else Tend,
        hook_class=[LogData, LogWork, LogGlobalErrorPostRun] + hooks,
        custom_controller_params=controller_params,
        use_MPI=True,
        comm=comm_time,
        **problem_args,
    )

    t_now = perf_counter()
    logger.debug(f'Finished run in {t_now - t_last:.2e} s')
    t_last = perf_counter()

    # record all the metrics
    stats_all = filter_stats(stats, comm=comm_sweep)
    comm_sweep.Free()

    for key, mapping in MAPPINGS.items():
        if crash:
            data[key] += [np.nan]
            continue
        me = get_sorted(stats_all, comm=comm_time, type=mapping[0], recomputed=mapping[2])
        if len(me) == 0:
            data[key] += [np.nan]
        else:
            data[key] += [mapping[1]([you[1] for you in me])]

    t_now = perf_counter()
    logger.debug(f'Recorded all data after {t_now - t_last:.2e} s')
    t_last = perf_counter()

    comm_time.Free()
    comm.Free()
    return stats


def get_parameter(dictionary, where):
    """
    Get a parameter at a certain position in a dictionary of dictionaries.

    Args:
        dictionary (dict): The dictionary
        where (list): The list of keys leading to the value you want

    Returns:
        The value of the dictionary
    """
    if len(where) == 1:
        return dictionary[where[0]]
    else:
        return get_parameter(dictionary[where[0]], where[1:])


def set_parameter(dictionary, where, parameter):
    """
    Set a parameter at a certain position in a dictionary of dictionaries

    Args:
        dictionary (dict): The dictionary
        where (list): The list of keys leading to the value you want to set
        parameter: Whatever you want to set the parameter to

    Returns:
        None
    """
    if len(where) == 1:
        dictionary[where[0]] = parameter
    else:
        set_parameter(dictionary[where[0]], where[1:], parameter)


def get_path(problem, strategy, num_procs, handle='', base_path='data/work_precision', num_procs_sweeper=1, mode=''):
    """
    Get the path to a certain data.

    Args:
        problem (function): A problem to run
        strategy (Strategy): SDC strategy
        num_procs (int): Number of processes for the time communicator
        handle (str): The name of the configuration
        base_path (str): Some path where all the files are stored
        num_procs_sweeper (int): Number of processes for the sweeper
        mode (str): The mode this was generated for

    Returns:
        str: The path to the data you are looking for
    """
    return f'{base_path}/{problem.__name__}-{strategy.__class__.__name__}-{handle}{"-wp" if handle else "wp"}-{num_procs}-{num_procs_sweeper}procs-{mode}.pickle'


def record_work_precision(
    problem,
    strategy,
    num_procs=1,
    custom_description=None,
    handle='',
    runs=1,
    comm_world=None,
    problem_args=None,
    param_range=None,
    Tend=None,
    hooks=None,
    num_procs_sweeper=1,
    mode='',
):
    """
    Run problem with strategy and record the cost parameters.

    Args:
        problem (function): A problem to run
        strategy (Strategy): SDC strategy
        num_procs (int): Number of processes for the time communicator
        custom_description (dict): Overwrite presets
        handle (str): The name of the configuration
        runs (int): Number of runs you want to do
        comm_world (mpi4py.MPI.Intracomm): Communicator that is available for the entire script
        num_procs_sweeper (int): Number of processes for the sweeper

    Returns:
        None
    """
    if get_forbidden_combinations(problem, strategy):
        return None

    data = {}

    # prepare precision parameters
    param = strategy.precision_parameter
    description = merge_descriptions(
        strategy.get_custom_description(problem, num_procs),
        {} if custom_description is None else custom_description,
    )
    if param == 'e_tol':
        power = 10.0
        set_parameter(description, strategy.precision_parameter_loc[:-1] + ['dt_min'], 0)
        exponents = [-3, -2, -1, 0, 1, 2, 3][::-1]
        if problem.__name__ == 'run_vdp':
            exponents = [-4, -3, -2, -1, 0, 1, 2]
    elif param == 'dt':
        power = 2.0
        exponents = [-1, 0, 1, 2, 3][::-1]
    elif param == 'restol':
        power = 10.0
        exponents = [-2, -1, 0, 1, 2, 3]
        if problem.__name__ == 'run_vdp':
            exponents = [-4, -3, -2, -1, 0, 1]
    else:
        raise NotImplementedError(f"I don't know how to get default value for parameter \"{param}\"")

    where = strategy.precision_parameter_loc
    default = get_parameter(description, where)
    param_range = [default * power**i for i in exponents] if param_range is None else param_range

    if problem.__name__ == 'run_quench':
        if param == 'restol':
            param_range = [1e-5, 1e-6, 1e-7, 1e-8, 1e-9]
        elif param == 'dt':
            param_range = [1.25, 2.5, 5.0, 10.0, 20.0][::-1]

    # run multiple times with different parameters
    for i in range(len(param_range)):
        set_parameter(description, where, param_range[i])

        data[param_range[i]] = {key: [] for key in MAPPINGS.keys()}
        data[param_range[i]]['param'] = [param_range[i]]
        data[param_range[i]][param] = [param_range[i]]

        description = merge_descriptions(
            descA=description, descB=strategy.get_description_for_tolerance(problem=problem, param=param_range[i])
        )
        for _j in range(runs):
            if comm_world.rank == 0:
                logger.log(
                    24,
                    f'Starting: {problem.__name__}: {strategy} {handle} {num_procs}-{num_procs_sweeper} procs, {param}={param_range[i]:.2e}',
                )
            single_run(
                problem,
                strategy,
                data[param_range[i]],
                custom_description=description,
                comm_world=comm_world,
                problem_args=problem_args,
                num_procs=num_procs,
                hooks=hooks,
                Tend=Tend,
                num_procs_sweeper=num_procs_sweeper,
            )

            comm_world.Barrier()

            if comm_world.rank == 0:
                if np.isfinite(data[param_range[i]]["k_linear"][-1]):
                    k_type = "k_linear"
                elif np.isfinite(data[param_range[i]]["k_Newton"][-1]):
                    k_type = 'k_Newton'
                else:
                    k_type = "k_SDC"
                logger.log(
                    25,
                    f'{problem.__name__}: {strategy} {handle} {num_procs}-{num_procs_sweeper} procs, {param}={param_range[i]:.2e}: e={data[param_range[i]]["e_global"][-1]}, t={data[param_range[i]]["t"][-1]}, {k_type}={data[param_range[i]][k_type][-1]}',
                )

    if comm_world.rank == 0:
        import socket
        import time

        data['meta'] = {
            'hostname': socket.gethostname(),
            'time': time.time,
            'runs': runs,
        }
        path = get_path(problem, strategy, num_procs, handle, num_procs_sweeper=num_procs_sweeper, mode=mode)
        with open(path, 'wb') as f:
            logger.debug(f'Dumping file \"{path}\"')
            pickle.dump(data, f)
        return data


def load(**kwargs):
    """
    Load stored data. Arguments are passed on to `get_path`

    Returns:
        dict: The data
    """
    path = get_path(**kwargs)
    with open(path, 'rb') as f:
        logger.debug(f'Loading file \"{path}\"')
        data = pickle.load(f)
    return data


def extract_data(data, work_key, precision_key):
    """
    Get the work and precision from a data object.

    Args:
        data (dict): Data from work-precision measurements
        work_key (str): Name of variable on x-axis
        precision_key (str): Name of variable on y-axis

    Returns:
        list: Work
        list: Precision
    """
    keys = [key for key in data.keys() if key not in ['meta']]
    work = [np.nanmean(data[key][work_key]) for key in keys]
    precision = [np.nanmean(data[key][precision_key]) for key in keys]
    return work, precision


def get_order(work_key='e_global', precision_key='param', strategy=None, handle=None, **kwargs):
    data = load(**kwargs, strategy=strategy, handle=handle)
    work, precision = extract_data(data, work_key, precision_key)

    order = [np.log(precision[i + 1] / precision[i]) / np.log(work[i + 1] / work[i]) for i in range(len(work) - 1)]

    print(f'Order for {strategy} {handle}: {np.mean(order):.2f}')


def plot_work_precision(
    problem,
    strategy,
    num_procs,
    ax,
    work_key='k_SDC',
    precision_key='e_global',
    handle='',
    plotting_params=None,
    comm_world=None,
    num_procs_sweeper=1,
    mode='',
):  # pragma: no cover
    """
    Plot data from running a problem with a strategy.

    Args:
        problem (function): A problem to run
        strategy (Strategy): SDC strategy
        num_procs (int): Number of processes for the time communicator
        ax (matplotlib.pyplot.axes): Somewhere to plot
        work_key (str): The key in the recorded data you want on the x-axis
        precision_key (str): The key in the recorded data you want on the y-axis
        handle (str): The name of the configuration
        plotting_params (dict): Will be passed when plotting
        comm_world (mpi4py.MPI.Intracomm): Communicator that is available for the entire script
        num_procs_sweeper (int): Number of processes for the sweeper
        mode (str): The of the configurations you want to retrieve

    Returns:
        None
    """
    if comm_world.rank > 0 or get_forbidden_combinations(problem, strategy):
        return None

    data = load(
        problem=problem,
        strategy=strategy,
        num_procs=num_procs,
        handle=handle,
        num_procs_sweeper=num_procs_sweeper,
        mode=mode,
    )

    work, precision = extract_data(data, work_key, precision_key)
    keys = [key for key in data.keys() if key not in ['meta']]

    for key in [work_key, precision_key]:
        rel_variance = [np.std(data[me][key]) / max([np.nanmean(data[me][key]), 1.0]) for me in keys]
        if not all(me < 1e-1 or not np.isfinite(me) for me in rel_variance):
            logger.warning(
                f"Variance in \"{key}\" for {get_path(problem, strategy, num_procs, handle, num_procs_sweeper=num_procs_sweeper, mode=mode)} too large! Got {rel_variance}"
            )

    style = merge_descriptions(
        {**strategy.style, 'label': f'{strategy.style["label"]}{f" {handle}" if handle else ""}'},
        plotting_params if plotting_params else {},
    )

    ax.loglog(work, precision, **style)

    # get_order(
    #     problem=problem,
    #     strategy=strategy,
    #     num_procs=num_procs,
    #     handle=handle,
    #     work_key=work_key,
    #     precision_key=precision_key,
    # )

    if 't' in [work_key, precision_key]:
        meta = data.get('meta', {})

        if meta.get('hostname', None) in ['thomas-work']:
            ax.text(0.1, 0.1, "Laptop timings!", transform=ax.transAxes)
        if meta.get('runs', None) == 1:
            ax.text(0.1, 0.2, "No sampling!", transform=ax.transAxes)


def plot_parallel_efficiency_diagonalSDC(
    ax, work_key, precision_key, num_procs_sweeper, num_procs=1, **kwargs
):  # pragma: no cover
    serial_data = load(
        num_procs=num_procs,
        num_procs_sweeper=1,
        **kwargs,
    )
    parallel_data = load(
        num_procs=num_procs,
        num_procs_sweeper=num_procs_sweeper,
        **kwargs,
    )
    serial_work, serial_precision = extract_data(serial_data, work_key, precision_key)
    parallel_work, parallel_precision = extract_data(parallel_data, work_key, precision_key)
    # assert np.allclose(serial_precision, parallel_precision)

    serial_work = np.asarray(serial_work)
    parallel_work = np.asarray(parallel_work)

    # ax.loglog(serial_work, serial_precision)
    # ax.loglog(parallel_work, parallel_precision)

    speedup = serial_work / parallel_work
    parallel_efficiency = np.median(speedup) / num_procs_sweeper
    ax.plot(serial_precision, speedup)
    ax.set_xscale('log')
    ax.set_ylabel('speedup')

    if 't' in [work_key, precision_key]:
        meta = parallel_data.get('meta', {})

        if meta.get('hostname', None) in ['thomas-work']:
            ax.text(0.1, 0.1, "Laptop timings!", transform=ax.transAxes)
        if meta.get('runs', None) == 1:
            ax.text(0.1, 0.2, "No sampling!", transform=ax.transAxes)

    return np.median(speedup), parallel_efficiency


def decorate_panel(ax, problem, work_key, precision_key, num_procs=1, title_only=False):  # pragma: no cover
    """
    Decorate a plot

    Args:
        ax (matplotlib.pyplot.axes): Somewhere to plot
        problem (function): A problem to run
        work_key (str): The key in the recorded data you want on the x-axis
        precision_key (str): The key in the recorded data you want on the y-axis
        num_procs (int): Number of processes for the time communicator
        title_only (bool): Put only the title on top, or do the whole shebang

    Returns:
        None
    """
    labels = {
        'k_SDC': 'SDC iterations',
        'k_SDC_no_restart': 'SDC iterations (restarts excluded)',
        'k_Newton': 'Newton iterations',
        'k_Newton_no_restart': 'Newton iterations (restarts excluded)',
        'k_rhs': 'right hand side evaluations',
        't': 'wall clock time / s',
        'e_global': 'global error',
        'e_global_rel': 'relative global error',
        'e_local_max': 'max. local error',
        'restart': 'restarts',
        'dt_max': r'$\Delta t_\mathrm{max}$',
        'dt_min': r'$\Delta t_\mathrm{min}$',
        'dt_sigma': r'$\sigma(\Delta t)$',
        'dt_mean': r'$\bar{\Delta t}$',
        'param': 'parameter',
        'u0_increment_max': r'$\| \Delta u_0 \|_{\infty} $',
        'u0_increment_mean': r'$\bar{\Delta u_0}$',
        'u0_increment_max_no_restart': r'$\| \Delta u_0 \|_{\infty} $ (restarts excluded)',
        'u0_increment_mean_no_restart': r'$\bar{\Delta u_0}$ (restarts excluded)',
        'k_linear': 'Linear solver iterations',
        'speedup': 'Speedup',
        'nprocs': r'$N_\mathrm{procs}$',
        '': '',
    }

    if not title_only:
        ax.set_xlabel(labels.get(work_key, 'work'))
        ax.set_ylabel(labels.get(precision_key, 'precision'))
        # ax.legend(frameon=False)

    titles = {
        'run_vdp': 'Van der Pol',
        'run_Lorenz': 'Lorenz attractor',
        'run_Schroedinger': r'Schr\"odinger',
        'run_quench': 'Quench',
        'run_AC': 'Allen-Cahn',
    }
    ax.set_title(titles.get(problem.__name__, ''))


def execute_configurations(
    problem,
    configurations,
    work_key,
    precision_key,
    num_procs,
    ax,
    decorate,
    record,
    runs,
    comm_world,
    plotting,
    Tend=None,
    num_procs_sweeper=1,
    mode='',
):
    """
    Run for multiple configurations.

    Args:
        problem (function): A problem to run
        configurations (dict): The configurations you want to run with
        work_key (str): The key in the recorded data you want on the x-axis
        precision_key (str): The key in the recorded data you want on the y-axis
        num_procs (int): Number of processes for the time communicator
        ax (matplotlib.pyplot.axes): Somewhere to plot
        decorate (bool): Whether to decorate fully or only put the title
        record (bool): Whether to only plot or also record the data first
        runs (int): Number of runs you want to do
        comm_world (mpi4py.MPI.Intracomm): Communicator that is available for the entire script
        plotting (bool): Whether to plot something
        num_procs_sweeper (int): Number of processes for the sweeper
        mode (str): What you want to look at

    Returns:
        None
    """
    for _, config in configurations.items():
        for strategy in config['strategies']:
            shared_args = {
                'problem': problem,
                'strategy': strategy,
                'handle': config.get('handle', ''),
                'num_procs': config.get('num_procs', num_procs),
                'num_procs_sweeper': config.get('num_procs_sweeper', num_procs_sweeper),
            }
            if record:
                logger.debug('Recording work precision')
                record_work_precision(
                    **shared_args,
                    custom_description=config.get('custom_description', {}),
                    runs=runs,
                    comm_world=comm_world,
                    problem_args=config.get('problem_args', {}),
                    param_range=config.get('param_range', None),
                    hooks=config.get('hooks', None),
                    Tend=Tend,
                    mode=mode,
                )
            if plotting and comm_world.rank == 0:
                logger.debug('Plotting')
                plot_work_precision(
                    **shared_args,
                    work_key=work_key,
                    precision_key=precision_key,
                    ax=ax,
                    plotting_params=config.get('plotting_params', {}),
                    comm_world=comm_world,
                    mode=mode,
                )

    if comm_world.rank == 0:
        decorate_panel(
            ax=ax,
            problem=problem,
            work_key=work_key,
            precision_key=precision_key,
            num_procs=num_procs,
            title_only=not decorate,
        )


def get_configs(mode, problem):
    """
    Get configurations for work-precision plots. These are dictionaries containing strategies and handles and so on.

    Args:
        mode (str): The of the configurations you want to retrieve
        problem (function): A problem to run

    Returns:
        dict: Configurations
    """
    configurations = {}
    if mode == 'regular':
        from pySDC.projects.Resilience.strategies import AdaptivityStrategy, BaseStrategy, IterateStrategy

        handle = 'regular'
        configurations[0] = {
            'handle': handle,
            'strategies': [AdaptivityStrategy(useMPI=True), BaseStrategy(useMPI=True), IterateStrategy(useMPI=True)],
        }
    elif mode == 'step_size_limiting':
        from pySDC.implementations.convergence_controller_classes.step_size_limiter import StepSizeLimiter
        from pySDC.projects.Resilience.strategies import AdaptivityStrategy, ESDIRKStrategy

        limits = [
            25.0,
            50.0,
        ]
        colors = ['teal', 'magenta']
        markers = ['v', 'x']
        markersize = 9
        for i in range(len(limits)):
            configurations[i] = {
                'custom_description': {'convergence_controllers': {StepSizeLimiter: {'dt_max': limits[i]}}},
                'handle': f'steplimiter{limits[i]:.0f}',
                'strategies': [AdaptivityStrategy(useMPI=True)],
                'plotting_params': {
                    'color': colors[i],
                    'marker': markers[i],
                    'label': rf'$\Delta t \leq {{{limits[i]:.0f}}}$',
                    # 'ls': '',
                    'markersize': markersize,
                },
                'num_procs': 1,
            }
        configurations[99] = {
            'custom_description': {},
            'handle': 'no limits',
            'plotting_params': {
                'label': 'no limiter',
                # 'ls': '',
                'markersize': markersize,
            },
            'strategies': [AdaptivityStrategy(useMPI=True)],
            'num_procs': 1,
        }
    elif mode == 'dynamic_restarts':
        """
        Compare Block Gauss-Seidel SDC with restarting the first step in the block or the first step that exceeded the error threshold.
        """
        from pySDC.projects.Resilience.strategies import AdaptivityStrategy, AdaptivityRestartFirstStep

        desc = {}
        desc['sweeper_params'] = {'num_nodes': 3, 'QI': 'IE'}
        desc['step_params'] = {'maxiter': 5}

        ls = {
            1: '-',
            2: '--',
            3: '-.',
            4: ':',
            5: ':',
        }

        configurations[-1] = {
            'strategies': [AdaptivityStrategy(useMPI=True)],
            'num_procs': 1,
        }

        for num_procs in [4, 2]:
            plotting_params = {'ls': ls[num_procs], 'label': f'adaptivity {num_procs} procs'}
            configurations[num_procs] = {
                'strategies': [AdaptivityStrategy(useMPI=True), AdaptivityRestartFirstStep(useMPI=True)],
                'custom_description': desc,
                'num_procs': num_procs,
                'plotting_params': plotting_params,
            }

    elif mode == 'compare_strategies':
        """
        Compare the different SDC strategies.
        """
        from pySDC.projects.Resilience.strategies import (
            AdaptivityStrategy,
            kAdaptivityStrategy,
            AdaptivityPolynomialError,
            BaseStrategy,
        )

        configurations[2] = {
            'strategies': [kAdaptivityStrategy(useMPI=True)],
        }
        configurations[1] = {
            'strategies': [AdaptivityPolynomialError(useMPI=True)],
        }
        configurations[0] = {
            'custom_description': {
                'step_params': {'maxiter': 5},
                'sweeper_params': {'num_nodes': 3, 'quad_type': 'RADAU-RIGHT'},
            },
            'strategies': [
                AdaptivityStrategy(useMPI=True),
                BaseStrategy(useMPI=True),
            ],
        }

    elif mode == 'interpolate_between_restarts':
        """
        Compare adaptivity with interpolation between restarts and without
        """
        from pySDC.projects.Resilience.strategies import AdaptivityPolynomialError

        i = 0
        for interpolate_between_restarts, handle, ls in zip(
            [True, False], ['Interpolation between restarts', 'regular'], ['--', '-']
        ):
            configurations[i] = {
                'strategies': [
                    AdaptivityPolynomialError(interpolate_between_restarts=interpolate_between_restarts, useMPI=True)
                ],
                'plotting_params': {'ls': ls},
                'handle': handle,
            }
            i += 1
    elif mode == 'diagonal_SDC':
        """
        Run diagonal SDC with different number of nodes and ranks. You can use this to compute a speedup, but it's not strong scaling!
        """
        from pySDC.projects.Resilience.strategies import AdaptivityPolynomialError

        if problem.__name__ in ['run_Schroedinger']:
            from pySDC.implementations.sweeper_classes.imex_1st_order_MPI import imex_1st_order_MPI as parallel_sweeper
        else:
            from pySDC.implementations.sweeper_classes.generic_implicit_MPI import (
                generic_implicit_MPI as parallel_sweeper,
            )

        for parallel in [False, True]:
            desc = {'sweeper_class': parallel_sweeper} if parallel else {}
            for num_nodes, ls in zip([3, 4, 2], ['-', '--', ':', '-.']):
                configurations[num_nodes + (99 if parallel else 0)] = {
                    'custom_description': {**desc, 'sweeper_params': {'num_nodes': num_nodes}},
                    'strategies': [
                        AdaptivityPolynomialError(useMPI=True, newton_inexactness=True, linear_inexactness=True)
                    ],
                    'num_procs_sweeper': num_nodes if parallel else 1,
                    'num_procs': 1,
                    'handle': f'{num_nodes} nodes',
                    'plotting_params': {
                        'ls': ls,
                        'label': f'{num_nodes} procs',
                        # **{'color': 'grey' if parallel else None},
                    },
                }

    elif mode == 'parallel_efficiency':
        """
        Compare parallel runs of the step size adaptive SDC
        """
        from pySDC.projects.Resilience.strategies import AdaptivityStrategy, AdaptivityPolynomialError

        if problem.__name__ in ['run_Schroedinger', 'run_AC']:
            from pySDC.implementations.sweeper_classes.imex_1st_order_MPI import imex_1st_order_MPI as parallel_sweeper
        else:
            from pySDC.implementations.sweeper_classes.generic_implicit_MPI import (
                generic_implicit_MPI as parallel_sweeper,
            )

        desc = {}
        desc['sweeper_params'] = {'num_nodes': 3, 'QI': 'IE', 'QE': 'EE'}
        desc['step_params'] = {'maxiter': 5}

        ls = {
            1: '-',
            2: '--',
            3: '-.',
            4: '--',
            5: ':',
            12: ':',
        }

        for num_procs in [4, 1]:
            plotting_params = (
                {'ls': ls[num_procs], 'label': fr'$\Delta t$-adaptivity $N$={num_procs}x1'} if num_procs > 1 else {}
            )
            configurations[num_procs] = {
                'strategies': [AdaptivityStrategy(useMPI=True)],
                'custom_description': desc.copy(),
                'num_procs': num_procs,
                'plotting_params': plotting_params.copy(),
            }
            configurations[num_procs * 100 + 79] = {
                'custom_description': {'sweeper_class': parallel_sweeper},
                'strategies': [
                    AdaptivityPolynomialError(useMPI=True, newton_inexactness=True, linear_inexactness=True)
                ],
                'num_procs_sweeper': 3,
                'num_procs': num_procs,
                'plotting_params': {
                    'ls': ls.get(num_procs * 3, '-'),
                    'label': rf'$\Delta t$-$k$-adaptivity $N$={num_procs}x3',
                },
            }

        configurations[num_procs * 200 + 79] = {
            'strategies': [AdaptivityPolynomialError(useMPI=True, newton_inexactness=True, linear_inexactness=True)],
            'num_procs': 1,
        }

    elif mode[:13] == 'vdp_stiffness':
        """
        Run van der Pol with different parameter for the nonlinear term, which controls the stiffness.
        """
        from pySDC.projects.Resilience.strategies import AdaptivityStrategy, ERKStrategy, ESDIRKStrategy

        mu = float(mode[14:])

        problem_desc = {'problem_params': {'mu': mu}}

        desc = {}
        desc['sweeper_params'] = {'num_nodes': 3, 'QI': 'IE'}
        desc['step_params'] = {'maxiter': 5}
        desc['problem_params'] = problem_desc['problem_params']

        ls = {
            1: '-',
            2: '--',
            3: '-.',
            4: ':',
            5: ':',
        }

        for num_procs in [5]:
            plotting_params = {'ls': ls[num_procs], 'label': f'GSSDC {num_procs} procs'}
            configurations[num_procs] = {
                'strategies': [AdaptivityStrategy(True)],
                'custom_description': desc,
                'num_procs': num_procs,
                'plotting_params': plotting_params,
                'handle': mode,
            }

        configurations[1] = {
            'strategies': [AdaptivityStrategy(True)],
            'custom_description': desc,
            'num_procs': 1,
            'plotting_params': {'ls': ls[1], 'label': 'SDC'},
            'handle': mode,
        }

        configurations[2] = {
            'strategies': [ERKStrategy(useMPI=True)],
            'num_procs': 1,
            'handle': mode,
            'plotting_params': {'label': 'CP5(4)'},
            'custom_description': problem_desc,
        }
        configurations[4] = {
            'strategies': [ESDIRKStrategy(useMPI=True)],
            'num_procs': 1,
            'handle': mode,
            'plotting_params': {'label': 'ESDIRK5(3)'},
            'custom_description': problem_desc,
        }
    elif mode == 'inexactness':
        """
        Compare inexact SDC to exact SDC
        """
        from pySDC.projects.Resilience.strategies import (
            AdaptivityPolynomialError,
        )

        if problem.__name__ in ['run_Schroedinger']:
            from pySDC.implementations.sweeper_classes.imex_1st_order_MPI import imex_1st_order_MPI as parallel_sweeper
        else:
            from pySDC.implementations.sweeper_classes.generic_implicit_MPI import (
                generic_implicit_MPI as parallel_sweeper,
            )

        strategies = [
            AdaptivityPolynomialError,
        ]

        inexactness = {
            'newton_inexactness': True,
            'linear_inexactness': True,
        }
        no_inexactness = {
            'newton_inexactness': False,
            'linear_inexactness': False,
            'SDC_maxiter': 99,
            'use_restol_rel': False,
        }

        configurations[1] = {
            'custom_description': {'sweeper_class': parallel_sweeper},
            'strategies': [me(useMPI=True, **no_inexactness) for me in strategies],
            'num_procs_sweeper': 3,
            'handle': 'exact',
            'plotting_params': {'ls': '--'},
        }
        configurations[0] = {
            'custom_description': {'sweeper_class': parallel_sweeper},
            'strategies': [me(useMPI=True, **inexactness) for me in strategies],
            'handle': 'inexact',
            'num_procs_sweeper': 3,
        }
    elif mode == 'compare_adaptivity':
        """
        Compare various modes of adaptivity
        """
        # TODO: configurations not final!
        from pySDC.projects.Resilience.strategies import (
            # AdaptivityCollocationTypeStrategy,
            # AdaptivityCollocationRefinementStrategy,
            AdaptivityStrategy,
            # AdaptivityExtrapolationWithinQStrategy,
            ESDIRKStrategy,
            ARKStrategy,
            AdaptivityPolynomialError,
        )

        if problem.__name__ in ['run_Schroedinger']:
            from pySDC.implementations.sweeper_classes.imex_1st_order_MPI import imex_1st_order_MPI as parallel_sweeper
        else:
            from pySDC.implementations.sweeper_classes.generic_implicit_MPI import (
                generic_implicit_MPI as parallel_sweeper,
            )

        inexactness_params = {
            # 'double_adaptivity': True,
            'newton_inexactness': True,
            'linear_inexactness': True,
        }

        strategies = [
            AdaptivityPolynomialError,
            # AdaptivityCollocationTypeStrategy,
            # AdaptivityExtrapolationWithinQStrategy,
        ]

        # restol = None
        # for strategy in strategies:
        #     strategy.restol = restol

        configurations[1] = {
            'custom_description': {'sweeper_class': parallel_sweeper},
            'strategies': [me(useMPI=True, **inexactness_params) for me in strategies],
            'handle': 'parallel',
            'num_procs_sweeper': 3,
            'plotting_params': {'ls': '-', 'label': '3 procs'},
        }
        configurations[2] = {
            'strategies': [me(useMPI=True, **inexactness_params) for me in strategies],
            'plotting_params': {'ls': '--'},
        }
        configurations[4] = {
            'custom_description': {'step_params': {'maxiter': 5}},
            'strategies': [AdaptivityStrategy(useMPI=True)],
        }

        desc_RK = {}
        configurations[-1] = {
            'strategies': [
                ARKStrategy(useMPI=True) if problem.__name__ == 'run_Schroedinger' else ESDIRKStrategy(useMPI=True),
            ],
            'num_procs': 1,
            'custom_description': desc_RK,
        }

    elif mode == 'preconditioners':
        """
        Compare different preconditioners
        """
        from pySDC.projects.Resilience.strategies import (
            AdaptivityStrategy,
            IterateStrategy,
            BaseStrategy,
            ESDIRKStrategy,
            ERKStrategy,
            AdaptivityPolynomialError,
        )

        inexacness = True
        strategies = [
            AdaptivityPolynomialError(
                useMPI=True, SDC_maxiter=29, newton_inexactness=inexacness, linear_inexactness=inexacness
            ),
            BaseStrategy(useMPI=True),
        ]

        desc = {}
        desc['sweeper_params'] = {
            'num_nodes': 3,
        }
        # desc['step_params'] = {'maxiter': 5}

        precons = ['IE', 'LU']
        ls = ['-.', '--', '-', ':']
        for i in range(len(precons) + 1):
            if i < len(precons):
                desc['sweeper_params']['QI'] = precons[i]
                handle = precons[i]
            else:
                handle = None
            configurations[i] = {
                'strategies': strategies,
                'custom_description': copy.deepcopy(desc),
                'handle': handle,
                'plotting_params': {'ls': ls[i]},
            }

    elif mode == 'RK_comp':
        """
        Compare parallel adaptive SDC to Runge-Kutta
        """
        from pySDC.projects.Resilience.strategies import (
            AdaptivityStrategy,
            ERKStrategy,
            ESDIRKStrategy,
            ARKStrategy,
            AdaptivityPolynomialError,
        )

        if problem.__name__ in ['run_Schroedinger', 'run_AC']:
            from pySDC.implementations.sweeper_classes.imex_1st_order_MPI import imex_1st_order_MPI as parallel_sweeper
        else:
            from pySDC.implementations.sweeper_classes.generic_implicit_MPI import (
                generic_implicit_MPI as parallel_sweeper,
            )

        desc = {}
        desc['sweeper_params'] = {'num_nodes': 3, 'QI': 'IE', 'QE': "EE"}
        desc['step_params'] = {'maxiter': 5}

        desc_poly = {}
        desc_poly['sweeper_class'] = parallel_sweeper

        ls = {
            1: '-',
            2: '--',
            3: '-.',
            4: ':',
            5: ':',
        }

        configurations[3] = {
            'custom_description': desc_poly,
            'strategies': [AdaptivityPolynomialError(useMPI=True)],
            'num_procs': 1,
            'num_procs_sweeper': 3,
            'plotting_params': {'label': r'$\Delta t$-$k$-adaptivity $N$=1x3'},
        }
        configurations[-1] = {
            'strategies': [
                ERKStrategy(useMPI=True),
                ARKStrategy(useMPI=True)
                if problem.__name__ in ['run_Schroedinger', 'run_AC']
                else ESDIRKStrategy(useMPI=True),
            ],
            'num_procs': 1,
        }
        configurations[2] = {
            'strategies': [AdaptivityStrategy(useMPI=True)],
            'custom_description': desc,
            'num_procs': 4,
            'plotting_params': {'label': r'$\Delta t$-adaptivity $N$=4x1'},
        }

    elif mode == 'RK_comp_high_order':
        """
        Compare higher order SDC than we can get with RKM to RKM
        """
        from pySDC.projects.Resilience.strategies import (
            AdaptivityStrategy,
            ERKStrategy,
            ESDIRKStrategy,
            ARKStrategy,
            AdaptivityPolynomialError,
        )

        if problem.__name__ in ['run_Schroedinger']:
            from pySDC.implementations.sweeper_classes.imex_1st_order_MPI import imex_1st_order_MPI as parallel_sweeper
        else:
            from pySDC.implementations.sweeper_classes.generic_implicit_MPI import (
                generic_implicit_MPI as parallel_sweeper,
            )

        desc = {}
        desc['sweeper_params'] = {'num_nodes': 4, 'QI': 'IE', 'QE': "EE"}
        desc['step_params'] = {'maxiter': 7}

        desc_poly = {}
        desc_poly['sweeper_class'] = parallel_sweeper
        desc_poly['sweeper_params'] = {'num_nodes': 4}

        ls = {
            1: '-',
            2: '--',
            3: '-.',
            4: ':',
            5: ':',
        }

        desc_RK = {}
        if problem.__name__ in ['run_Schroedinger']:
            desc_RK['problem_params'] = {'imex': True}

        configurations[3] = {
            'custom_description': desc_poly,
            'strategies': [AdaptivityPolynomialError(useMPI=True)],
            'num_procs': 1,
            'num_procs_sweeper': 4,
        }
        configurations[-1] = {
            'strategies': [
                ERKStrategy(useMPI=True),
                ARKStrategy(useMPI=True) if problem.__name__ in ['run_Schroedinger'] else ESDIRKStrategy(useMPI=True),
            ],
            'num_procs': 1,
            'custom_description': desc_RK,
        }

        configurations[2] = {
            'strategies': [AdaptivityStrategy(useMPI=True)],
            'custom_description': desc,
            'num_procs': 4,
        }
    elif mode == 'avoid_restarts':
        """
        Test how well avoiding restarts works.
        """
        from pySDC.projects.Resilience.strategies import (
            AdaptivityStrategy,
            AdaptivityAvoidRestartsStrategy,
            AdaptivityPolynomialStrategy,
        )

        desc = {'sweeper_params': {'QI': 'IE'}, 'step_params': {'maxiter': 3}}
        param_range = [1e-3, 1e-5]
        configurations[0] = {
            'strategies': [AdaptivityPolynomialStrategy(useMPI=True)],
            'plotting_params': {'ls': '--'},
            'custom_description': desc,
            'param_range': param_range,
        }
        configurations[1] = {
            'strategies': [AdaptivityAvoidRestartsStrategy(useMPI=True)],
            'plotting_params': {'ls': '-.'},
            'custom_description': desc,
            'param_range': param_range,
        }
        configurations[2] = {
            'strategies': [AdaptivityStrategy(useMPI=True)],
            'custom_description': desc,
            'param_range': param_range,
        }
    else:
        raise NotImplementedError(f'Don\'t know the mode "{mode}"!')

    return configurations


def get_fig(x=1, y=1, **kwargs):  # pragma: no cover
    """
    Get a figure to plot in.

    Args:
        x (int): How many panels in horizontal direction you want
        y (int): How many panels in vertical direction you want

    Returns:
        matplotlib.pyplot.Figure
    """
    width = 1.0
    ratio = 1.0 if y == 2 else 0.5
    keyword_arguments = {
        'figsize': figsize_by_journal('Springer_Numerical_Algorithms', width, ratio),
        'layout': 'constrained',
        **kwargs,
    }
    return plt.subplots(y, x, **keyword_arguments)


def save_fig(
    fig, name, work_key, precision_key, legend=True, format='pdf', base_path='data', squares=True, ncols=None, **kwargs
):  # pragma: no cover
    """
    Save a figure with a legend on the bottom.

    Args:
        fig (matplotlib.pyplot.Figure): Figure you want to save
        name (str): Name of the plot to put in the path
        work_key (str): The key in the recorded data you want on the x-axis
        precision_key (str): The key in the recorded data you want on the y-axis
        legend (bool): Put a legend or not
        format (str): Format to store the figure with
        base_path (str): Some path where all the files are stored
        squares (bool): Adjust aspect ratio to squares if true

    Returns:
        None
    """
    handles = []
    labels = []
    for ax in fig.get_axes():
        h, l = ax.get_legend_handles_labels()
        handles += [h[i] for i in range(len(h)) if l[i] not in labels]
        labels += [me for me in l if me not in labels]
        if squares:
            ax.set_box_aspect(1)
    order = np.argsort([me[0] for me in labels])
    fig.legend(
        [handles[i] for i in order],
        [labels[i] for i in order],
        loc='outside lower center',
        ncols=ncols if ncols else 3 if len(handles) % 3 == 0 else 4,
        frameon=False,
        fancybox=True,
    )

    path = f'{base_path}/wp-{name}-{work_key}-{precision_key}.{format}'
    fig.savefig(path, bbox_inches='tight', **kwargs)
    print(f'Stored figure \"{path}\"')


def all_problems(mode='compare_strategies', plotting=True, base_path='data', **kwargs):  # pragma: no cover
    """
    Make a plot comparing various strategies for all problems.

    Args:
        work_key (str): The key in the recorded data you want on the x-axis
        precision_key (str): The key in the recorded data you want on the y-axis

    Returns:
        None
    """

    fig, axs = get_fig(2, 2)

    shared_params = {
        'work_key': 'k_SDC',
        'precision_key': 'e_global',
        'num_procs': 1,
        'runs': 1,
        'comm_world': MPI.COMM_WORLD,
        'record': False,
        'plotting': plotting,
        **kwargs,
    }

    problems = [run_vdp, run_quench, run_Schroedinger, run_AC]

    logger.log(26, f"Doing for all problems {mode}")
    for i in range(len(problems)):
        execute_configurations(
            **shared_params,
            problem=problems[i],
            ax=axs.flatten()[i],
            decorate=True,
            configurations=get_configs(mode, problems[i]),
            mode=mode,
        )

    if plotting and shared_params['comm_world'].rank == 0:
        save_fig(
            fig=fig,
            name=mode,
            work_key=shared_params['work_key'],
            precision_key=shared_params['precision_key'],
            legend=True,
            base_path=base_path,
            ncols=3 if mode in ['parallel_efficiency'] else None,
        )


def ODEs(mode='compare_strategies', plotting=True, base_path='data', **kwargs):  # pragma: no cover
    """
    Make a plot comparing various strategies for the two ODEs.

    Args:
        work_key (str): The key in the recorded data you want on the x-axis
        precision_key (str): The key in the recorded data you want on the y-axis

    Returns:
        None
    """

    fig, axs = get_fig(x=2, y=1)

    shared_params = {
        'work_key': 'k_SDC',
        'precision_key': 'e_global',
        'num_procs': 1,
        'runs': 1,
        'comm_world': MPI.COMM_WORLD,
        'record': False,
        'plotting': plotting,
        **kwargs,
    }

    problems = [run_vdp, run_Lorenz]

    for i in range(len(problems)):
        execute_configurations(
            **shared_params,
            problem=problems[i],
            ax=axs.flatten()[i],
            decorate=i == 0,
            configurations=get_configs(mode, problems[i]),
        )

    if plotting and shared_params['comm_world'].rank == 0:
        save_fig(
            fig=fig,
            name=f'ODEs-{mode}',
            work_key=shared_params['work_key'],
            precision_key=shared_params['precision_key'],
            legend=True,
            base_path=base_path,
        )


def single_problem(mode, problem, plotting=True, base_path='data', **kwargs):  # pragma: no cover
    """
    Make a plot for a single problem

    Args:
        mode (str): What you want to look at
        problem (function): A problem to run
    """
    fig, ax = get_fig(1, 1, figsize=figsize_by_journal('Springer_Numerical_Algorithms', 1, 0.8))

    params = {
        'work_key': 'k_SDC',
        'precision_key': 'e_global',
        'num_procs': 1,
        'runs': 1,
        'comm_world': MPI.COMM_WORLD,
        'record': False,
        'plotting': plotting,
        **kwargs,
    }

    logger.log(26, f"Doing single problem {mode}")
    execute_configurations(
        **params, problem=problem, ax=ax, decorate=True, configurations=get_configs(mode, problem), mode=mode
    )

    if plotting:
        save_fig(
            fig=fig,
            name=f'{problem.__name__}-{mode}',
            work_key=params['work_key'],
            precision_key=params['precision_key'],
            legend=False,
            base_path=base_path,
        )


def vdp_stiffness_plot(base_path='data', format='pdf', **kwargs):  # pragma: no cover
    fig, axs = get_fig(2, 2, sharex=True, sharey=True)

    # mus = [0, 5, 10, 15]
    mus = [0, 10, 20, 40]

    for i in range(len(mus)):
        params = {
            'runs': 1,
            'problem': run_vdp,
            'record': False,
            'work_key': 't',
            'precision_key': 'e_global',
            'comm_world': MPI.COMM_WORLD,
            **kwargs,
        }
        params['num_procs'] = min(params['comm_world'].size, 5)
        params['plotting'] = params['comm_world'].rank == 0

        configurations = get_configs(mode=f'vdp_stiffness-{mus[i]}', problem=run_vdp)
        execute_configurations(**params, ax=axs.flatten()[i], decorate=True, configurations=configurations, Tend=100)
        axs.flatten()[i].set_title(rf'$\mu={{{mus[i]}}}$')

    fig.suptitle('Van der Pol')
    if params['comm_world'].rank == 0:
        save_fig(
            fig=fig,
            name='vdp-stiffness',
            work_key=params['work_key'],
            precision_key=params['precision_key'],
            legend=False,
            base_path=base_path,
            format=format,
        )


def aggregate_parallel_efficiency_plot():  # pragma: no cover
    """
    Make a "weak scaling" plot for diagonal SDC
    """
    from pySDC.projects.Resilience.strategies import AdaptivityPolynomialError

    fig, axs = plt.subplots(2, 2)

    _fig, _ax = plt.subplots(1, 1)
    num_procs = 1
    num_procs_sweeper = 2
    problem = run_quench

    num_procs_sweeper_list = [2, 3, 4]

    for problem, ax in zip([run_vdp, run_Lorenz, run_quench], axs.flatten()):
        speedup = []
        for num_procs_sweeper in num_procs_sweeper_list:
            s, e = plot_parallel_efficiency_diagonalSDC(
                ax=_ax,
                work_key='t',
                precision_key='e_global_rel',
                num_procs=num_procs,
                num_procs_sweeper=num_procs_sweeper,
                problem=problem,
                strategy=AdaptivityPolynomialError(),
                mode='diagonal_SDC',
                handle=f'{num_procs_sweeper} nodes',
            )
            speedup += [s]
            decorate_panel(ax, problem, work_key='nprocs', precision_key='')

        ax.plot(num_procs_sweeper_list, speedup, label='speedup')
        ax.plot(
            num_procs_sweeper_list,
            [speedup[i] / num_procs_sweeper_list[i] for i in range(len(speedup))],
            label='parallel efficiency',
        )

    fig.tight_layout()
    save_fig(fig, 'parallel_efficiency', 'nprocs', 'speedup')


if __name__ == "__main__":
    comm_world = MPI.COMM_WORLD

    # record = False
    # for mode in [
    #     'compare_strategies',
    #     'RK_comp',
    #     'parallel_efficiency',
    # ]:
    #     params = {
    #         'mode': mode,
    #         'runs': 5,
    #         'plotting': comm_world.rank == 0,
    #     }
    #     params_single = {
    #         **params,
    #         'problem': run_AC,
    #     }
    #     single_problem(**params_single, work_key='t', precision_key='e_global_rel', record=record)

    all_params = {
        'record': True,
        'runs': 5,
        'work_key': 't',
        'precision_key': 'e_global_rel',
        'plotting': comm_world.rank == 0,
    }

    for mode in [
        'RK_comp',
        'parallel_efficiency',
        'compare_strategies',
    ]:
        all_problems(**all_params, mode=mode)
        comm_world.Barrier()

    if comm_world.rank == 0:
        plt.show()
